<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Web app that fills IRS Form 8949 with data from a CSV file.">
  <meta property="og:title" content="Fill IRS Form 8949 with CSV">
  <meta property="og:description" content="Web app that fills IRS Form 8949 with data from a CSV file.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://fill-8949.ardis.lu/">
  <link rel="preconnect" href="https://rsms.me/">
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
  <link rel="icon" href="data:,">
  <link rel="preload" href="https://rsms.me/inter/font-files/InterVariable.woff2?v=4.1" crossorigin as="font">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/tslib@1.14.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/pako@1.0.11/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/@pdf-lib/standard-fonts@1.0.0/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/@pdf-lib/upng@1.0.1/+esm">
  <title>Fill IRS Form 8949 with CSV</title>
  <style>
    :root {
      font-family: 'Inter', sans-serif;
      --primary-color: #90EE90;
      --primary-dark: #60c060;
      --primary-light: #b0ffb0;
      --text-color: #2a3b2a;
      --bg-color: #f0fff0;
      --card-bg: #ffffff;
      --accent-color: #3a5a3a;
    }

    @supports (font-variation-settings: normal) {
      :root {
        font-family: 'Inter var', sans-serif;
      }
    }

    body {
      background: var(--bg-color);
      color: var(--text-color);
      min-block-size: 100dvb;
      inline-size: calc(100% - 32px);
      margin-inline: auto;
      margin-block: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 16px;
    }

    section.info {
      margin-block-start: 16px;
    }

    p {
      margin: 0;
    }

    h1 {
      margin: 0;
      margin-block-end: 24px;
      font-size: 2rem;
      color: var(--accent-color);
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
    }

    .source {
      margin-block-start: 24px;
    }

    a {
      color: var(--accent-color);
      font-weight: 700;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    a:hover,
    a:focus {
      color: var(--primary-dark);
      text-decoration: underline 0.1em;
      text-underline-offset: 0.15em;
    }

    main {
      margin-block-end: 16px;
    }

    svg {
      block-size: 1rem;
      inline-size: 1rem;
      /* Optically center the SVG */
      transform: translateY(3px);
    }

    form {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    label {
      inline-size: fit-content;
      font-weight: 500;
    }

    label:not([for="headers"]) {
      /* Expand clickable area to cover flex gap */
      padding-block-end: 8px;
      margin-block-end: -8px;
    }

    label[for="headers"] {
      padding-inline-start: 4px;
      margin-inline-start: -4px;
    }

    input {
      inline-size: fit-content;
      font-size: 1rem;
    }

    input[type="checkbox"] {
      width: 16px;
      aspect-ratio: 1;
      margin: 0;
      accent-color: var(--primary-dark);
    }

    select,
    button,
    input::file-selector-button {
      inline-size: fit-content;
      color: var(--text-color);
      font-size: 1rem;
      background-color: var(--primary-color);
      border: 1px solid var(--primary-dark);
      border-radius: 4px;
      padding: 4px 8px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    :is(label, select, input, button, input::file-selector-button):is(:hover, :focus) {
      cursor: pointer;
      filter: brightness(105%);
      transform: translateY(-1px);
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
      transition: all 0.2s ease;
    }

    [data-submitting] button {
      cursor: not-allowed;
      background: var(--primary-light);
      opacity: 0.7;
      filter: unset;
      transform: none;
      box-shadow: none;
      transition: unset;
    }

    ol {
      margin: 0;
      margin-block-end: 24px;
    }

    .card {
      align-self: center;
      inline-size: min(60ch, 100% - 32px);
      background: var(--card-bg);
      border: 1px solid var(--primary-dark);
      border-radius: 8px;
      padding: 24px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
    }

    .disclaimer,
    .privacy,
    .directions {
      color: var(--accent-color);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .inline-container {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .inline-spinner {
      display: none;
      box-sizing: border-box;
      block-size: 1em;
      inline-size: 1em;
      border: 0.25em solid transparent;
      border-block-start: 0.25em solid var(--accent-color);
      border-radius: 50%;
      animation: spin 1s infinite;
    }

    @keyframes spin {
      100% {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <section class="info card">
    <h1>Fill IRS Form 8949 with CSV</h1>
    <p class="disclaimer"><b>Disclaimer:</b> the author of this tool is not responsible for any errors or omissions, or for the results obtained from the use of this tool. All outputs are provided "as is", with no guarantee of completeness, accuracy, or of the results obtained from the use of this tool, and without warranty of any kind. The output from this tool is provided with the understanding that the author is not herein engaged in rendering legal, accounting, tax, or other professional advice and services.</p>
    <p class="privacy"><b>Privacy:</b> the CSV parsing and PDF filling operations occur in your web browser. Your CSV data does not leave your computer.</p>
    <p class="source"><a href="https://github.com/ardislu/fill-8949-with-csv">Click here to view this tool's source code on GitHub.</a></p>
  </section>

  <main class="card">
    <p class="directions"><b>Directions:</b>
    <ol>
      <li>Download two copies of the CSV template (<a id="template-link" href="#"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" alt="">
            <path d="M12 17V3" />
            <path d="m6 11 6 6 6-6" />
            <path d="M19 21H5" />
          </svg>template.csv</a>).</li>
      <li>Fill the templates with data to populate the tables on page 1 (short-term transactions) and page 2 (long-term transactions) of <a href="https://www.irs.gov/form8949">IRS Form 8949</a>.</li>
      <li>Select the filled CSV templates in the file pickers below.</li>
      <li>Click "Download Filled Form 8949" to download a copy of Form 8949 with the CSV data filled into it.</li>
    </ol>
    </p>
    <form>
      <label for="year">Tax year</label>
      <select id="year" name="year">
        <option value="2024">2024</option>
        <option value="2023">2023</option>
        <option value="2022">2022</option>
        <option value="2021">2021</option>
        <option value="2020">2020</option>
        <option value="2019">2019</option>
        <option value="2018">2018</option>
        <option value="2017">2017</option>
        <option value="2016">2016</option>
        <option value="2015">2015</option>
        <option value="2014">2014</option>
        <option value="2013">2013</option>
      </select>

      <label for="short">Short-term transactions</label>
      <input type="file" id="short" name="short" accept="text/csv" required>

      <label for="long">Long-term transactions</label>
      <input type="file" id="long" name="long" accept="text/csv" required>

      <div class="inline-container">
        <input type="checkbox" id="headers" name="headers" checked>
        <label for="headers">Data has headers</label>
      </div>

      <div class="inline-container">
        <button>Download Filled Form 8949</button>
        <span class="inline-spinner"></span>
      </div>
    </form>
  </main>

  <script type="module">
    import Papa from 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/+esm';
    import { PDFArray, PDFDict, PDFDocument, PDFName, PDFString, PDFBool } from 'https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm'; // Added PDFBool

    const button = document.querySelector('button');
    const spinner = document.querySelector('span.inline-spinner');

    // Use a custom id generator instead of crypto.randomUUID() to reduce PDF file size
    const annotationIds = (function* () {
      let i = 0;
      while (true) {
        yield `f${i}`; // Must be unique within the PDF
        i++;
      }
    })();

    // Duplicate all annotations exactly, except for the "T" key. The "T" key ("text label") is used
    // as a unique identifier for the annotation and must be updated or else all annotations with
    // the same "T" key will have the same value.
    // Original code from: https://github.com/Hopding/pdf-lib/issues/151
    function cloneAnnotations(page) {
      const form = page.doc.catalog.lookup(PDFName.of('AcroForm'), PDFDict);
      if (!form) return; // Exit if no AcroForm found
      const fields = form.lookup(PDFName.of('Fields'), PDFArray);
      if (!fields) return; // Exit if no Fields array found

      const annotations = page.node.Annots();
      if (!annotations) return; // Exit if no Annots found

      for (let i = 0; i < annotations.size(); i++) {
        const annotRef = annotations.get(i);
        const annotDict = annotations.lookupMaybe(i, PDFDict);

        // Ensure it's a widget annotation and has a /T key
        if (annotDict && annotDict.get(PDFName.of('Subtype')) === PDFName.of('Widget') && annotDict.has(PDFName.of('T'))) {
           // Check if this annotation reference is already in the Fields array to avoid duplication
           let alreadyInFields = false;
           for (let j=0; j < fields.size(); j++) {
             if (fields.get(j) === annotRef) {
                alreadyInFields = true;
                break;
             }
           }
           
           // If not already in main Fields array, clone, give unique T, and add.
           if (!alreadyInFields) {
              const clonedAnnotDict = annotDict.clone(page.doc.context);
              clonedAnnotDict.set(PDFName.of('T'), PDFString.of(annotationIds.next().value));
              // Add the *reference* to the cloned dictionary to the Fields array.
              // Note: This assumes cloning automatically registers the new object and gives it a ref.
              // If pdf-lib's clone doesn't auto-register, we might need pdfDoc.context.register(clonedAnnotDict)
              // before pushing the reference. Let's assume it does for now as per typical design.
              const clonedAnnotRef = page.doc.context.register(clonedAnnotDict);
              fields.push(clonedAnnotRef); 
           } else {
             // If it *is* in the Fields array, we might still need a unique ID if multiple pages
             // reference the *same* original field definition but need independent values.
             // This part is tricky - simply setting T might not be enough if the original field is shared.
             // A safer approach for truly independent fields might be restructuring how fields are added/cloned.
             // For now, let's stick to the original goal of adding copies unique *per page*.
             // If the *same* field ref is used on *multiple* copied pages, they might still link.
             // The `annotationIds.next().value` ensures each *widget annotation instance* on the page gets a new T key.
             annotDict.set(PDFName.of('T'), PDFString.of(annotationIds.next().value));
           }
        }
      }
    };

    async function generatePage(f8949, data, type) {
      // Determine source page index based on type
      const sourcePageIndex = type === 'short' ? 0 : 1;
      
      // Get the original page *once* per type to avoid repeated lookups if possible
      // This assumes f8949 contains the original template pages at indices 0 and 1
      const originalPage = f8949.getPage(sourcePageIndex);
    
      // Copy the determined page
      const [page] = await f8949.copyPages(f8949, [sourcePageIndex]);
      
      // Clone annotations specific to THIS newly copied page
      cloneAnnotations(page);

      let cellNumber = 0;
      // Offset might vary depending on exact form structure; 5 was the original value
      const offset = 5; 
      
      // Get annotations *from the newly copied page*
      const annots = page.node.Annots(); 
      if (!annots) return page; // Return unmodified page if no annotations

      // Populate the fields on the copied page
      for (const row of data) {
        for (const cell of row) {
          const annotIndex = cellNumber + offset;
          // Use lookupMaybe to avoid errors if index is out of bounds
          const a = annots.lookupMaybe(annotIndex, PDFDict); 
          if (a && a.get(PDFName.of('Subtype')) === PDFName.of('Widget')) { // Check if it's a widget field
              a.set(PDFName.of('V'), PDFString.of(String(cell))); // Ensure cell is string
              a.set(PDFName.of('Ff'), PDFString.of('0')); // Optionally reset flags if needed, e.g., clear ReadOnly if set
              // We might need to update the appearance stream (/AP) as well, but
              // setting NeedAppearances = true on the AcroForm should handle this globally.
          } else {
              console.warn(`Annotation at index ${annotIndex} not found or not a widget on ${type} page.`);
          }
          cellNumber++;
        }
      }

      return page;
    }

    async function generate8949(f8949Bytes, year, shortData, longData) {
      const f8949 = await PDFDocument.load(f8949Bytes, { 
          // Option to ignore minor errors during loading if needed
          // ignoreEncryption: true, 
          // updateFieldAppearances: true // Let pdf-lib try to update appearances
      });

      // --- XFA Removal Start ---
      try {
          const form = f8949.getForm();
          const acroFormDict = form?.catalog?.lookup(PDFName.of('AcroForm'), PDFDict);

          if (acroFormDict?.has(PDFName.of('XFA'))) {
              console.log("XFA found, removing...");
              acroFormDict.delete(PDFName.of('XFA'));
              
              // Set NeedAppearances to true - crucial for non-XFA viewers
              acroFormDict.set(PDFName.of('NeedAppearances'), PDFBool.True);
              console.log("XFA removed and NeedAppearances set.");
          } else {
              console.log("No XFA field found in AcroForm.");
              // Even if no XFA, setting NeedAppearances might be beneficial
              if (acroFormDict) {
                 acroFormDict.set(PDFName.of('NeedAppearances'), PDFBool.True);
                 console.log("NeedAppearances set (no XFA found).");
              }
          }
      } catch (error) {
        console.error("Error accessing or modifying AcroForm:", error);
        // Decide how to handle: maybe continue without removal, maybe throw error
      }
      // --- XFA Removal End ---

      const pagePromises = [];
      const chunkSize = 14; // Rows per page in the form

      // Generate short-term pages
      for (let i = 0; i < shortData.length; i += chunkSize) {
        const chunk = shortData.slice(i, i + chunkSize);
        pagePromises.push(generatePage(f8949, chunk, 'short'));
      }
      // Add a blank short-term page if no short-term data
      if (shortData.length === 0) { 
        console.log("No short term data, adding blank page 1 template.");
        pagePromises.push(
          f8949.copyPages(f8949, [0]).then(pages => {
             const blankPage = pages[0];
             cloneAnnotations(blankPage); // Ensure fields are independent even on blank pages
             return blankPage;
          })
        );
      }
      
      // Generate long-term pages
      for (let i = 0; i < longData.length; i += chunkSize) {
        const chunk = longData.slice(i, i + chunkSize);
        pagePromises.push(generatePage(f8949, chunk, 'long'));
      }
       // Add a blank long-term page if no long-term data
      if (longData.length === 0) { 
        console.log("No long term data, adding blank page 2 template.");
         pagePromises.push(
          f8949.copyPages(f8949, [1]).then(pages => {
             const blankPage = pages[0];
             cloneAnnotations(blankPage); // Ensure fields are independent even on blank pages
             return blankPage;
          })
        );
      }
      
      // Wait for all page generation promises to resolve
      const generatedPages = await Promise.all(pagePromises);

      // Remove the original template pages *after* copying and processing
      // Remove in reverse order to avoid index shifting issues
       if (f8949.getPageCount() > 1) f8949.removePage(1); 
       if (f8949.getPageCount() > 0) f8949.removePage(0);

      // Add the newly generated pages (now containing data or being blank templates)
      for (const page of generatedPages) {
        f8949.addPage(page);
      }

      // Log final page count
      console.log(`Final PDF page count: ${f8949.getPageCount()}`);

      // Save the modified PDF
      // Use updateFieldAppearances option here might be redundant if NeedAppearances=true worked,
      // but can be added as a fallback.
      return f8949.save({ updateFieldAppearances: true }).then(data => 
         new File([data.buffer], `f8949_${year}_filled.pdf`, { type: 'application/pdf' }) // Changed name slightly
      );
    }

    function download(file) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(file);
      a.download = file.name;
      document.body.appendChild(a); // Append to body for Firefox compatibility
      a.click();
      document.body.removeChild(a); // Clean up
      URL.revokeObjectURL(a.href); // Release object URL
    }

    async function parseCsv(file, hasHeaders) {
      return new Promise((resolve, reject) => { // Return the promise directly
        if (!file || file.size === 0) {
          console.log("Empty file provided for parsing, resolving with empty data.");
          resolve({ data: [] }); // Resolve with empty data structure expected by PapaParse
          return;
        }
        Papa.parse(file, {
          header: false, // We handle headers manually if checked
          skipEmptyLines: 'greedy',
          complete: (results) => {
              console.log(`Parsed CSV: ${results.data.length} rows found.`);
              const data = results.data;
              if (hasHeaders && data.length > 0) {
                 console.log("Removing header row.");
                 data.shift(); // Remove header row
              }
              // Validate row structure (optional but recommended)
              // e.g., check if rows have expected number of columns
              resolve({ data: data }); // Resolve with the processed data under 'data' key
          },
          error: (error) => {
              console.error("CSV Parsing Error:", error);
              reject(error);
          }
        });
      });
    }

    document.querySelector('#template-link').addEventListener('click', e => {
      e.preventDefault();
      const csv = 'Description of property,Date acquired,Date sold or disposed of,Proceeds (sales price),Cost or other basis,Code(s) from instructions,Amount of adjustment,Gain or (loss)';
      const encoded = new TextEncoder().encode(csv);
      const file = new File([encoded], 'template.csv', { type: 'text/csv;charset=utf-8' }); // Added charset
      download(file);
    });

    document.querySelector('form').addEventListener('submit', async e => {
      e.preventDefault();

      if (e.target.hasAttribute('data-submitting')) {
        return;
      }
      e.target.setAttribute('data-submitting', '');
      spinner.style.display = 'inline-block';
      button.disabled = true; // Disable button

      try {
          const form = new FormData(e.target);
          const year = form.get('year');
          const shortFile = form.get('short');
          const longFile = form.get('long');
          const hasHeaders = form.get('headers') === 'on';

          // Fetch PDF template first
          let f8949Bytes;
          try {
              const response = await fetch(`/forms/f8949--${year}.pdf`);
              if (!response.ok) {
                  throw new Error(`Failed to fetch PDF form for year ${year}: ${response.statusText}`);
              }
              f8949Bytes = await response.arrayBuffer();
              console.log(`Successfully fetched PDF for ${year}`);
          } catch (fetchError) {
              console.error("Error fetching PDF:", fetchError);
              alert(`Could not load the Form 8949 PDF for ${year}. Please check the year selection or try again later.`);
              spinner.style.display = 'none';
              e.target.removeAttribute('data-submitting');
              button.disabled = false;
              return; // Stop execution
          }

          // Parse CSV files concurrently
          const [shortResult, longResult] = await Promise.all([
              parseCsv(shortFile, hasHeaders).catch(err => { console.error("Short CSV parse error:", err); return { data: [] }; }), // Catch error here
              parseCsv(longFile, hasHeaders).catch(err => { console.error("Long CSV parse error:", err); return { data: [] }; })   // Catch error here
          ]);
          
          const shortData = shortResult.data;
          const longData = longResult.data;

          console.log(`Short-term data rows: ${shortData.length}`);
          console.log(`Long-term data rows: ${longData.length}`);
          
          if(shortFile.size > 0 && shortData.length === 0 && !hasHeaders) {
               console.warn("Short term file provided but parsed as empty. Check CSV format?");
          }
          if(longFile.size > 0 && longData.length === 0 && !hasHeaders) {
               console.warn("Long term file provided but parsed as empty. Check CSV format?");
          }

          // Generate the PDF
          console.log("Generating PDF...");
          const generatedPdfFile = await generate8949(f8949Bytes, year, shortData, longData);
          console.log("PDF generation complete. Starting download...");
          
          // Download the generated file
          download(generatedPdfFile);
          console.log("Download initiated.");

      } catch (error) {
          console.error("An error occurred during form processing:", error);
          alert("An unexpected error occurred while generating the PDF. Please check the console for details.");
      } finally {
          // Ensure UI is reset regardless of success or failure
          spinner.style.display = 'none';
          e.target.removeAttribute('data-submitting');
          button.disabled = false; // Re-enable button
      }
    });
  </script>
</body>

</html>