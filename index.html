<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Web app that fills IRS Form 8949 with data from a CSV file.">
  <meta property="og:title" content="Fill IRS Form 8949 with CSV">
  <meta property="og:description" content="Web app that fills IRS Form 8949 with data from a CSV file.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://fill-8949.ardis.lu/">
  <link rel="preconnect" href="https://rsms.me/">
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
  <link rel="icon" href="data:,">
  <link rel="preload" href="https://rsms.me/inter/font-files/InterVariable.woff2?v=4.1" crossorigin as="font">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/tslib@1.14.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/pako@1.0.11/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/@pdf-lib/standard-fonts@1.0.0/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/@pdf-lib/upng@1.0.1/+esm">
  <title>Fill IRS Form 8949 with CSV</title>
  <style>
    :root {
      --primary: #1a4d7c;
      --primary-light: #2975b9;
      --primary-dark: #0f3155;
      --secondary: #f8f9fa;
      --accent: #4cc9f0;
      --text: #333;
      --text-light: #6c757d;
      --success: #28a745;
      --error: #dc3545;
      --border-radius: 8px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
      font-family: 'Inter', sans-serif;
    }

    @supports (font-variation-settings: normal) {
      :root {
        font-family: 'Inter var', sans-serif;
      }
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      color: var(--text);
      min-height: 100vh;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      line-height: 1.6;
    }

    .container {
      width: min(1000px, 100%);
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 2rem;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 1rem;
      color: var(--primary);
      line-height: 1.2;
    }

    .subtitle {
      color: var(--text-light);
      font-size: 1.2rem;
      max-width: 600px;
      margin: 0 auto;
    }

    .card {
      background: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 2rem;
      margin-bottom: 2rem;
      transition: var(--transition);
    }

    .card:hover {
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
    }

    .disclaimer, .privacy {
      background: #f8f9fa;
      border-left: 4px solid var(--primary);
      padding: 1rem;
      margin: 1.5rem 0;
      border-radius: 0 var(--border-radius) var(--border-radius) 0;
    }

    .disclaimer b, .privacy b {
      color: var(--primary);
      display: block;
      margin-bottom: 0.5rem;
    }

    .steps {
      counter-reset: step;
      margin: 2rem 0;
    }

    .step {
      display: flex;
      margin-bottom: 1.5rem;
      padding: 0 0 0 3rem;
      position: relative;
    }

    .step:before {
      counter-increment: step;
      content: counter(step);
      position: absolute;
      left: 0;
      top: 0;
      background: var(--primary);
      color: white;
      width: 2rem;
      height: 2rem;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }

    .form-container {
      background: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 2rem;
    }

    .form-group {
      margin-bottom: 1.5rem;
    }

    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: var(--primary-dark);
    }

    select, input[type="file"] {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border: 1px solid #ced4da;
      border-radius: var(--border-radius);
      background-color: #fff;
      transition: var(--transition);
    }

    select {
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%231a4d7c' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 1rem center;
      background-size: 1em;
      padding-right: 2.5rem;
    }

    input[type="file"] {
      padding: 0.5rem;
    }

    input[type="file"]::file-selector-button {
      font-size: 0.9rem;
      padding: 0.5rem 1rem;
      margin-right: 1rem;
      border-radius: var(--border-radius);
      background-color: var(--secondary);
      border: 1px solid #ced4da;
      color: var(--text);
      cursor: pointer;
      transition: var(--transition);
    }

    input[type="file"]::file-selector-button:hover {
      background-color: #e2e6ea;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    input[type="checkbox"] {
      margin-right: 0.5rem;
      width: 1.25rem;
      height: 1.25rem;
      accent-color: var(--primary);
    }

    button {
      background-color: var(--primary);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: var(--transition);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    button:hover {
      background-color: var(--primary-light);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    [data-submitting] button {
      cursor: not-allowed;
      background-color: var(--text-light);
      opacity: 0.7;
      transform: none;
    }

    .button-container {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 1rem;
    }

    .download-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--primary);
      font-weight: 600;
      text-decoration: none;
      transition: var(--transition);
    }

    .download-link:hover {
      color: var(--primary-light);
      text-decoration: underline;
    }

    .download-link svg {
      transition: var(--transition);
    }

    .download-link:hover svg {
      transform: translateY(2px);
    }

    .source {
      margin-top: 1.5rem;
      text-align: center;
    }

    .source a {
      color: var(--primary);
      font-weight: 500;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .source a:hover {
      color: var(--primary-light);
      text-decoration: underline;
    }

    .spinner {
      display: none;
      width: 1.5rem;
      height: 1.5rem;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-left: 0.75rem;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    footer {
      margin-top: 3rem;
      text-align: center;
      color: var(--text-light);
      font-size: 0.9rem;
    }

    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }
      
      .card, .form-container {
        padding: 1.5rem;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .step {
        padding-left: 2.5rem;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>IRS Form 8949 Filler</h1>
      <p class="subtitle">Easily fill IRS Form 8949 with your CSV data</p>
    </header>

    <section class="card">
      <div class="disclaimer">
        <b>Disclaimer</b>
        <p>The author of this tool is not responsible for any errors or omissions, or for the results obtained from the use of this tool. All outputs are provided "as is", with no guarantee of completeness, accuracy, or of the results obtained from the use of this tool, and without warranty of any kind. The output from this tool is provided with the understanding that the author is not herein engaged in rendering legal, accounting, tax, or other professional advice and services.</p>
      </div>

      <div class="privacy">
        <b>Privacy</b>
        <p>The CSV parsing and PDF filling operations occur in your web browser. Your CSV data does not leave your computer.</p>
      </div>
    </section>

    <div class="form-container">
      <div class="steps">
        <div class="step">
          <div>
            <h3>Download CSV Templates</h3>
            <p>Download two copies of the CSV template for short-term and long-term transactions.</p>
            <a href="#" id="template-link" class="download-link">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
              </svg>
              template.csv
            </a>
          </div>
        </div>

        <div class="step">
          <div>
            <h3>Fill the Templates</h3>
            <p>Fill the templates with data to populate the tables on page 1 (short-term transactions) and page 2 (long-term transactions) of <a href="https://www.irs.gov/form8949" target="_blank">IRS Form 8949</a>.</p>
          </div>
        </div>

        <div class="step">
          <div>
            <h3>Upload and Generate</h3>
            <p>Select the filled CSV templates and click "Generate Filled Form" to download your customized IRS Form 8949.</p>
          </div>
        </div>
      </div>

      <form>
        <div class="form-group">
          <label for="year">Tax Year</label>
          <select id="year" name="year">
            <option value="2024">2024</option>
            <option value="2023">2023</option>
            <option value="2022">2022</option>
            <option value="2021">2021</option>
            <option value="2020">2020</option>
            <option value="2019">2019</option>
            <option value="2018">2018</option>
            <option value="2017">2017</option>
            <option value="2016">2016</option>
            <option value="2015">2015</option>
            <option value="2014">2014</option>
            <option value="2013">2013</option>
          </select>
        </div>

        <div class="form-group">
          <label for="short">Short-term Transactions CSV</label>
          <input type="file" id="short" name="short" accept="text/csv" required>
        </div>

        <div class="form-group">
          <label for="long">Long-term Transactions CSV</label>
          <input type="file" id="long" name="long" accept="text/csv" required>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="headers" name="headers" checked>
          <label for="headers">CSV data has headers</label>
        </div>

        <div class="button-container">
          <button type="submit">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
            Generate Filled Form
          </button>
          <div class="spinner"></div>
        </div>

        <div class="source">
          <a href="https://github.com/ardislu/fill-8949-with-csv" target="_blank">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg>
            View source code on GitHub
          </a>
        </div>
      </form>
    </div>

    <footer>
      <p>&copy; 2025 IRS Form 8949 Filler Tool</p>
    </footer>
  </div>

  <script type="module">
    import Papa from 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/+esm';
    import { PDFArray, PDFDict, PDFDocument, PDFName, PDFString, PDFBool } from 'https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm'; // Added PDFBool

    const button = document.querySelector('button');
    const spinner = document.querySelector('.spinner');

    // Use a custom id generator instead of crypto.randomUUID() to reduce PDF file size
    const annotationIds = (function* () {
      let i = 0;
      while (true) {
        yield `f${i}`; // Must be unique within the PDF
        i++;
      }
    })();

    // Duplicate all annotations exactly, except for the "T" key. The "T" key ("text label") is used
    // as a unique identifier for the annotation and must be updated or else all annotations with
    // the same "T" key will have the same value.
    // Original code from: https://github.com/Hopding/pdf-lib/issues/151
    function cloneAnnotations(page) {
      const form = page.doc.catalog.lookup(PDFName.of('AcroForm'), PDFDict);
      if (!form) return; // Exit if no AcroForm found
      const fields = form.lookup(PDFName.of('Fields'), PDFArray);
      if (!fields) return; // Exit if no Fields array found

      const annotations = page.node.Annots();
      if (!annotations) return; // Exit if no Annots found

      for (let i = 0; i < annotations.size(); i++) {
        const annotRef = annotations.get(i);
        const annotDict = annotations.lookupMaybe(i, PDFDict);

        // Ensure it's a widget annotation and has a /T key
        if (annotDict && annotDict.get(PDFName.of('Subtype')) === PDFName.of('Widget') && annotDict.has(PDFName.of('T'))) {
           // Check if this annotation reference is already in the Fields array to avoid duplication
           let alreadyInFields = false;
           for (let j=0; j < fields.size(); j++) {
             if (fields.get(j) === annotRef) {
                alreadyInFields = true;
                break;
             }
           }
           
           // If not already in main Fields array, clone, give unique T, and add.
           if (!alreadyInFields) {
              const clonedAnnotDict = annotDict.clone(page.doc.context);
              clonedAnnotDict.set(PDFName.of('T'), PDFString.of(annotationIds.next().value));
              // Add the *reference* to the cloned dictionary to the Fields array.
              // Note: This assumes cloning automatically registers the new object and gives it a ref.
              // If pdf-lib's clone doesn't auto-register, we might need pdfDoc.context.register(clonedAnnotDict)
              // before pushing the reference. Let's assume it does for now as per typical design.
              const clonedAnnotRef = page.doc.context.register(clonedAnnotDict);
              fields.push(clonedAnnotRef); 
           } else {
             // If it *is* in the Fields array, we might still need a unique ID if multiple pages
             // reference the *same* original field definition but need independent values.
             // This part is tricky - simply setting T might not be enough if the original field is shared.
             // A safer approach for truly independent fields might be restructuring how fields are added/cloned.
             // For now, let's stick to the original goal of adding copies unique *per page*.
             // If the *same* field ref is used on *multiple* copied pages, they might still link.
             // The `annotationIds.next().value` ensures each *widget annotation instance* on the page gets a new T key.
             annotDict.set(PDFName.of('T'), PDFString.of(annotationIds.next().value));
           }
        }
      }
    };

    async function generatePage(f8949, data, type) {
      // Determine source page index based on type
      const sourcePageIndex = type === 'short' ? 0 : 1;
      
      // Get the original page *once* per type to avoid repeated lookups if possible
      // This assumes f8949 contains the original template pages at indices 0 and 1
      const originalPage = f8949.getPage(sourcePageIndex);
    
      // Copy the determined page
      const [page] = await f8949.copyPages(f8949, [sourcePageIndex]);
      
      // Clone annotations specific to THIS newly copied page
      cloneAnnotations(page);

      let cellNumber = 0;
      // Offset might vary depending on exact form structure; 5 was the original value
      const offset = 5; 
      
      // Get annotations *from the newly copied page*
      const annots = page.node.Annots(); 
      if (!annots) return page; // Return unmodified page if no annotations

      // Populate the fields on the copied page
      for (const row of data) {
        for (const cell of row) {
          const annotIndex = cellNumber + offset;
          // Use lookupMaybe to avoid errors if index is out of bounds
          const a = annots.lookupMaybe(annotIndex, PDFDict); 
          if (a && a.get(PDFName.of('Subtype')) === PDFName.of('Widget')) { // Check if it's a widget field
              a.set(PDFName.of('V'), PDFString.of(String(cell))); // Ensure cell is string
              a.set(PDFName.of('Ff'), PDFString.of('0')); // Optionally reset flags if needed, e.g., clear ReadOnly if set
              // We might need to update the appearance stream (/AP) as well, but
              // setting NeedAppearances = true on the AcroForm should handle this globally.
          } else {
              console.warn(`Annotation at index ${annotIndex} not found or not a widget on ${type} page.`);
          }
          cellNumber++;
        }
      }

      return page;
    }

    async function generate8949(f8949Bytes, year, shortData, longData) {
      const f8949 = await PDFDocument.load(f8949Bytes, { 
          // Option to ignore minor errors during loading if needed
          // ignoreEncryption: true, 
          // updateFieldAppearances: true // Let pdf-lib try to update appearances
      });

      // --- XFA Removal Start ---
      try {
          const form = f8949.getForm();
          const acroFormDict = form?.catalog?.lookup(PDFName.of('AcroForm'), PDFDict);

          if (acroFormDict?.has(PDFName.of('XFA'))) {
              console.log("XFA found, removing...");
              acroFormDict.delete(PDFName.of('XFA'));
              
              // Set NeedAppearances to true - crucial for non-XFA viewers
              acroFormDict.set(PDFName.of('NeedAppearances'), PDFBool.True);
              console.log("XFA removed and NeedAppearances set.");
          } else {
              console.log("No XFA field found in AcroForm.");
              // Even if no XFA, setting NeedAppearances might be beneficial
              if (acroFormDict) {
                 acroFormDict.set(PDFName.of('NeedAppearances'), PDFBool.True);
                 console.log("NeedAppearances set (no XFA found).");
              }
          }
      } catch (error) {
        console.error("Error accessing or modifying AcroForm:", error);
        // Decide how to handle: maybe continue without removal, maybe throw error
      }
      // --- XFA Removal End ---

      const pagePromises = [];
      const chunkSize = 14; // Rows per page in the form

      // Generate short-term pages
      for (let i = 0; i < shortData.length; i += chunkSize) {
        const chunk = shortData.slice(i, i + chunkSize);
        pagePromises.push(generatePage(f8949, chunk, 'short'));
      }
      // Add a blank short-term page if no short-term data
      if (shortData.length === 0) { 
        console.log("No short term data, adding blank page 1 template.");
        pagePromises.push(
          f8949.copyPages(f8949, [0]).then(pages => {
             const blankPage = pages[0];
             cloneAnnotations(blankPage); // Ensure fields are independent even on blank pages
             return blankPage;
          })
        );
      }
      
      // Generate long-term pages
      for (let i = 0; i < longData.length; i += chunkSize) {
        const chunk = longData.slice(i, i + chunkSize);
        pagePromises.push(generatePage(f8949, chunk, 'long'));
      }
       // Add a blank long-term page if no long-term data
      if (longData.length === 0) { 
        console.log("No long term data, adding blank page 2 template.");
         pagePromises.push(
          f8949.copyPages(f8949, [1]).then(pages => {
             const blankPage = pages[0];
             cloneAnnotations(blankPage); // Ensure fields are independent even on blank pages
             return blankPage;
          })
        );
      }
      
      // Wait for all page generation promises to resolve
      const generatedPages = await Promise.all(pagePromises);

      // Remove the original template pages *after* copying and processing
      // Remove in reverse order to avoid index shifting issues
       if (f8949.getPageCount() > 1) f8949.removePage(1); 
       if (f8949.getPageCount() > 0) f8949.removePage(0);

      // Add the newly generated pages (now containing data or being blank templates)
      for (const page of generatedPages) {
        f8949.addPage(page);
      }

      // Log final page count
      console.log(`Final PDF page count: ${f8949.getPageCount()}`);

      // Save the modified PDF
      // Use updateFieldAppearances option here might be redundant if NeedAppearances=true worked,
      // but can be added as a fallback.
      return f8949.save({ updateFieldAppearances: true }).then(data => 
         new File([data.buffer], `f8949_${year}_filled.pdf`, { type: 'application/pdf' }) // Changed name slightly
      );
    }

    function download(file) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(file);
      a.download = file.name;
      document.body.appendChild(a); // Append to body for Firefox compatibility
      a.click();
      document.body.removeChild(a); // Clean up
      URL.revokeObjectURL(a.href); // Release object URL
    }

    async function parseCsv(file, hasHeaders) {
      return new Promise((resolve, reject) => { // Return the promise directly
        if (!file || file.size === 0) {
          console.log("Empty file provided for parsing, resolving with empty data.");
          resolve({ data: [] }); // Resolve with empty data structure expected by PapaParse
          return;
        }
        Papa.parse(file, {
          header: false, // We handle headers manually if checked
          skipEmptyLines: 'greedy',
          complete: (results) => {
              console.log(`Parsed CSV: ${results.data.length} rows found.`);
              const data = results.data;
              if (hasHeaders && data.length > 0) {
                 console.log("Removing header row.");
                 data.shift(); // Remove header row
              }
              // Validate row structure (optional but recommended)
              // e.g., check if rows have expected number of columns
              resolve({ data: data }); // Resolve with the processed data under 'data' key
          },
          error: (error) => {
              console.error("CSV Parsing Error:", error);
              reject(error);
          }
        });
      });
    }

    document.querySelector('#template-link').addEventListener('click', e => {
      e.preventDefault();
      const csv = 'Description of property,Date acquired,Date sold or disposed of,Proceeds (sales price),Cost or other basis,Code(s) from instructions,Amount of adjustment,Gain or (loss)';
      const encoded = new TextEncoder().encode(csv);
      const file = new File([encoded], 'template.csv', { type: 'text/csv;charset=utf-8' }); // Added charset
      download(file);
    });

    document.querySelector('form').addEventListener('submit', async e => {
      e.preventDefault();

      if (e.target.hasAttribute('data-submitting')) {
        return;
      }
      e.target.setAttribute('data-submitting', '');
      spinner.style.display = 'inline-block';
      button.disabled = true; // Disable button

      try {
          const form = new FormData(e.target);
          const year = form.get('year');
          const shortFile = form.get('short');
          const longFile = form.get('long');
          const hasHeaders = form.get('headers') === 'on';

          // Fetch PDF template first
          let f8949Bytes;
          try {
              const response = await fetch(`/forms/f8949--${year}.pdf`);
              if (!response.ok) {
                  throw new Error(`Failed to fetch PDF form for year ${year}: ${response.statusText}`);
              }
              f8949Bytes = await response.arrayBuffer();
              console.log(`Successfully fetched PDF for ${year}`);
          } catch (fetchError) {
              console.error("Error fetching PDF:", fetchError);
              alert(`Could not load the Form 8949 PDF for ${year}. Please check the year selection or try again later.`);
              spinner.style.display = 'none';
              e.target.removeAttribute('data-submitting');
              button.disabled = false;
              return; // Stop execution
          }

          // Parse CSV files concurrently
          const [shortResult, longResult] = await Promise.all([
              parseCsv(shortFile, hasHeaders).catch(err => { console.error("Short CSV parse error:", err); return { data: [] }; }), // Catch error here
              parseCsv(longFile, hasHeaders).catch(err => { console.error("Long CSV parse error:", err); return { data: [] }; })   // Catch error here
          ]);
          
          const shortData = shortResult.data;
          const longData = longResult.data;

          console.log(`Short-term data rows: ${shortData.length}`);
          console.log(`Long-term data rows: ${longData.length}`);
          
          if(shortFile.size > 0 && shortData.length === 0 && !hasHeaders) {
               console.warn("Short term file provided but parsed as empty. Check CSV format?");
          }
          if(longFile.size > 0 && longData.length === 0 && !hasHeaders) {
               console.warn("Long term file provided but parsed as empty. Check CSV format?");
          }

          // Generate the PDF
          console.log("Generating PDF...");
          const generatedPdfFile = await generate8949(f8949Bytes, year, shortData, longData);
          console.log("PDF generation complete. Starting download...");
          
          // Download the generated file
          download(generatedPdfFile);
          console.log("Download initiated.");

      } catch (error) {
          console.error("An error occurred during form processing:", error);
          alert("An unexpected error occurred while generating the PDF. Please check the console for details.");
      } finally {
          // Ensure UI is reset regardless of success or failure
          spinner.style.display = 'none';
          e.target.removeAttribute('data-submitting');
          button.disabled = false; // Re-enable button
      }
    });
  </script>
</body>

</html>