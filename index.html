<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Web app that fills IRS Form 8949 with data from a CSV file.">
  <meta property="og:title" content="Fill IRS Form 8949 with CSV">
  <meta property="og:description" content="Web app that fills IRS Form 8949 with data from a CSV file.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://form8949.urz.one/">

  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/tslib@1.14.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/pako@1.0.11/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/@pdf-lib/standard-fonts@1.0.0/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/@pdf-lib/upng@1.0.1/+esm">
  <title>Fill IRS Form 8949 with CSV</title>
  <style>
    /* CSS Styles remain the same as provided previously */
    :root {
      --primary: #1a4d7c;
      --primary-light: #2975b9;
      --primary-dark: #0f3155;
      --secondary: #f8f9fa;
      --accent: #4cc9f0;
      --text: #333;
      --text-light: #6c757d;
      --success: #28a745;
      --error: #dc3545;
      --border-radius: 8px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
      font-family: 'Inter', sans-serif;
    }

    @supports (font-variation-settings: normal) {
      :root {
        font-family: 'Inter var', sans-serif;
      }
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      color: var(--text);
      min-height: 100vh;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      line-height: 1.6;
    }

    .container {
      width: min(1000px, 100%);
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 2rem;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 1rem;
      color: var(--primary);
      line-height: 1.2;
    }

    .subtitle {
      color: var(--text-light);
      font-size: 1.2rem;
      max-width: 600px;
      margin: 0 auto;
    }

    .card {
      background: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 2rem;
      margin-bottom: 2rem;
      transition: var(--transition);
    }

    .card:hover {
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
    }

    .disclaimer, .privacy {
      background: #f8f9fa;
      border-left: 4px solid var(--primary);
      padding: 1rem;
      margin: 1.5rem 0;
      border-radius: 0 var(--border-radius) var(--border-radius) 0;
    }

    .disclaimer b, .privacy b {
      color: var(--primary);
      display: block;
      margin-bottom: 0.5rem;
    }

    .steps {
      counter-reset: step;
      margin: 2rem 0;
    }

    .step {
      display: flex;
      margin-bottom: 1.5rem;
      padding: 0 0 0 3rem;
      position: relative;
    }

    .step:before {
      counter-increment: step;
      content: counter(step);
      position: absolute;
      left: 0;
      top: 0;
      background: var(--primary);
      color: white;
      width: 2rem;
      height: 2rem;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }

    .form-container {
      background: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 2rem;
    }

    .form-group {
      margin-bottom: 1.5rem;
    }

    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: var(--primary-dark);
    }

    select, input[type="file"] {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border: 1px solid #ced4da;
      border-radius: var(--border-radius);
      background-color: #fff;
      transition: var(--transition);
    }

    select {
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%231a4d7c' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 1rem center;
      background-size: 1em;
      padding-right: 2.5rem;
    }

    input[type="file"] {
      padding: 0.5rem;
    }

    input[type="file"]::file-selector-button {
      font-size: 0.9rem;
      padding: 0.5rem 1rem;
      margin-right: 1rem;
      border-radius: var(--border-radius);
      background-color: var(--secondary);
      border: 1px solid #ced4da;
      color: var(--text);
      cursor: pointer;
      transition: var(--transition);
    }

    input[type="file"]::file-selector-button:hover {
      background-color: #e2e6ea;
    }

    .checkbox-group, .radio-group {
      display: flex;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    .radio-group {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
    }

    .radio-option {
      display: flex;
      align-items: center;
    }

    input[type="checkbox"], input[type="radio"] {
      margin-right: 0.5rem;
      width: 1.25rem;
      height: 1.25rem;
      accent-color: var(--primary);
    }

    button {
      background-color: var(--primary);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: var(--transition);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    button:hover {
      background-color: var(--primary-light);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    [data-submitting] button {
      cursor: not-allowed;
      background-color: var(--text-light);
      opacity: 0.7;
      transform: none;
    }

    .button-container {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 1rem;
    }

    .download-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--primary);
      font-weight: 600;
      text-decoration: none;
      transition: var(--transition);
    }

    .download-link:hover {
      color: var(--primary-light);
      text-decoration: underline;
    }

    .download-link svg {
      transition: var(--transition);
    }

    .download-link:hover svg {
      transform: translateY(2px);
    }

    .source {
      margin-top: 1.5rem;
      text-align: center;
    }

    .source a {
      color: var(--primary);
      font-weight: 500;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .source a:hover {
      color: var(--primary-light);
      text-decoration: underline;
    }

    .spinner {
      display: none;
      width: 1.5rem;
      height: 1.5rem;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-left: 0.75rem;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    footer {
      margin-top: 3rem;
      text-align: center;
      color: var(--text-light);
      font-size: 0.9rem;
    }

    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }

      .card, .form-container {
        padding: 1.5rem;
      }

      h1 {
        font-size: 2rem;
      }

      .step {
        padding-left: 2.5rem;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>IRS Form 8949 Filler</h1>
      <p class="subtitle">Easily fill IRS Form 8949 with your CSV data</p>
    </header>

    <section class="card">
      <div class="disclaimer">
        <b>Disclaimer</b>
        <p>The author of this tool is not responsible for any errors or omissions, or for the results obtained from the use of this tool. All outputs are provided "as is", with no guarantee of completeness, accuracy, or of the results obtained from the use of this tool, and without warranty of any kind. The output from this tool is provided with the understanding that the author is not herein engaged in rendering legal, accounting, tax, or other professional advice and services.</p>
      </div>

      <div class="privacy">
        <b>Privacy</b>
        <p>The CSV parsing and PDF filling operations occur in your web browser. Your CSV data does not leave your computer.</p>
      </div>
    </section>

    <div class="form-container">
      <div class="steps">
        <div class="step">
          <div>
            <h3>Download CSV Templates</h3>
            <p>Download two copies of the CSV template for short-term and long-term transactions.</p>
            <a href="#" id="template-link" class="download-link">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
              </svg>
              template.csv
            </a>
          </div>
        </div>

        <div class="step">
          <div>
            <h3>Fill the Templates</h3>
            <p>Fill the templates with data to populate the tables on page 1 (short-term transactions) and page 2 (long-term transactions) of <a href="https://www.irs.gov/form8949" target="_blank">IRS Form 8949</a>.</p>
          </div>
        </div>

        <div class="step">
          <div>
            <h3>Upload and Generate</h3>
            <p>Select the filled CSV templates and click "Generate Filled Form" to download your customized IRS Form 8949.</p>
          </div>
        </div>
      </div>

      <form>
        <div class="form-group">
          <label for="year">Tax Year</label>
          <select id="year" name="year">
            <option value="2024">2024</option>
            <option value="2023">2023</option>
            <option value="2022">2022</option>
            <option value="2021">2021</option>
            <option value="2020">2020</option>
            <option value="2019">2019</option>
            <option value="2018">2018</option>
            <option value="2017">2017</option>
            <option value="2016">2016</option>
            <option value="2015">2015</option>
            <option value="2014">2014</option>
            <option value="2013">2013</option>
          </select>
        </div>

        <div class="form-group">
          <label for="short">Short-term Transactions CSV</label>
          <input type="file" id="short" name="short" accept="text/csv" required>
        </div>

        <div class="form-group">
          <label for="long">Long-term Transactions CSV</label>
          <input type="file" id="long" name="long" accept="text/csv" required>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="headers" name="headers" checked>
          <label for="headers">CSV data has headers</label>
        </div>

        <div class="form-group">
          <label>Output Format</label>
          <div class="radio-group">
            <div class="radio-option">
              <input type="radio" id="format-form" name="format" value="form" checked>
              <label for="format-form">Form with Fields (Editable)</label>
            </div>
            <div class="radio-option">
              <input type="radio" id="format-static" name="format" value="static">
              <label for="format-static">Static PDF (Compatible with all viewers)</label>
            </div>
          </div>
        </div>

        <div class="button-container">
          <button type="submit">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
            Generate Filled Form
          </button>
          <div class="spinner"></div>
        </div>

        <div class="source">
          <a href="https://github.com/ardislu/fill-8949-with-csv" target="_blank">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg>
            View source code on GitHub
          </a>
        </div>
      </form>
    </div>

    <footer>
      <p>&copy; 2025 IRS Form 8949 Filler Tool</p> <!-- Note: Year might need update -->
    </footer>
  </div>

  <script type="module">
    import Papa from 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/+esm';
    // Import necessary classes from pdf-lib
    import { PDFArray, PDFDict, PDFDocument, PDFName, PDFString } from 'https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm';

    // Get references to DOM elements
    const button = document.querySelector('button');
    const spinner = document.querySelector('.spinner');
    const formElement = document.querySelector('form'); // Reference the form element

    // --- Annotation Cloning Logic ---
    // Custom ID generator for unique field names after cloning
    const annotationIds = (function* () {
      let i = 0;
      while (true) {
        yield `clone${i++}`; // Use a prefix to avoid potential collisions
      }
    })();

    // Function to clone annotations for copied pages, ensuring unique field names
    function cloneAnnotations(page, sourceDoc) { // Pass sourceDoc context if needed
      const context = page.doc.context; // Use the target document's context
      const acroFormRef = page.doc.catalog.get(PDFName.of('AcroForm'));
       if (!acroFormRef) {
            console.warn("Target AcroForm not found, cannot add cloned fields.");
           return;
       }
       const form = context.lookup(acroFormRef);
       if (!(form instanceof PDFDict)) return;

       let fields = form.lookupMaybe(PDFName.of('Fields'), PDFArray);
       if (!fields) {
            fields = context.obj([]);
            form.set(PDFName.of('Fields'), fields);
       }

      const annotsRef = page.node.get(PDFName.of('Annots'));
      if (!annotsRef) return; // No annotations on this page
       const annotations = context.lookup(annotsRef);
       if (!(annotations instanceof PDFArray)) return;

      for (let i = 0; i < annotations.size(); i++) {
        const annotRef = annotations.get(i);
        const originalAnnot = context.lookup(annotRef); // Annot is already in the target context due to page copy

        if (originalAnnot instanceof PDFDict && originalAnnot.get(PDFName.of('Subtype')) === PDFName.of('Widget') ) {
            // Found a form field widget
             const oldT = originalAnnot.get(PDFName.of('T')); // Get existing T value (field name)
             if(oldT) { // Only rename if it has a T value
                 const newT = PDFString.of(`${oldT.asString()}_${annotationIds.next().value}`); // Append unique ID
                 console.log(`Renaming field from ${oldT.asString()} to ${newT.asString()}`);
                 originalAnnot.set(PDFName.of('T'), newT); // Update T value in the cloned annotation
                 fields.push(annotRef); // Add reference to the AcroForm Fields array
            } else {
                 console.warn("Widget annotation found without a 'T' value (name). Cannot properly clone for AcroForm.");
            }

             // Optional: Update other properties if needed, e.g., Parent reference if part of a field hierarchy
        }
      }
       // Update the NeedAppearances flag if fields were added
       if (fields.size() > 0) {
           form.set(PDFName.of('NeedAppearances'), context.obj(true));
       }
    }

    // --- Page Filling Logic ---
    // Fills data into the fields of a specific page (which is a copy)
     async function fillPageData(page, data) {
       const form = page.doc.getForm(); // Get form from the context of the target page's doc
       const fieldsPerRow = 8; // Expected number of data columns per row
       const rowsPerPage = 14; // Expected number of data rows the form template page supports
       // TODO: Need a reliable way to map CSV column to actual PDF Field names on the template page.
       // This is the hardest part. Let's *assume* a naming convention for now, e.g.,
       // Row1_Col_a, Row1_Col_b, ..., Row1_Col_h
       // Row2_Col_a, Row2_Col_b, ..., Row2_Col_h ... Row14_Col_h

       for (let r = 0; r < data.length && r < rowsPerPage; r++) {
           const rowData = data[r]; // Get data for this CSV row
           for (let c = 0; c < rowData.length && c < fieldsPerRow; c++) {
               const cellValue = String(rowData[c] || ''); // Get cell value, ensure string

               // *** Attempt to find the field based on assumed naming convention ***
               // This needs to match EXACTLY how fields are named in your PDF template!
               const fieldName = `Row${r + 1}_Col_${String.fromCharCode(97 + c)}`; // e.g., Row1_Col_a, Row1_Col_b ...
                // You might need Row1.ColA, or Text1.0, Text1.1 etc. Check your template!

               try {
                    // Use getTextField, getCheckBox, etc. based on expected field type
                    const field = form.getTextField(fieldName); // Assuming text fields
                    field.setText(cellValue);
                    // Optional: Mark field as needing appearance update? pdf-lib usually handles this.
                    // field.updateAppearances(helveticaFont); // Requires font instance if needed
               } catch (e) {
                   // Field not found or wrong type - Log it and continue
                    console.warn(`Could not find or set field named "${fieldName}" on page. Error: ${e.message}`);
                    // If fields are just named sequentially like "Text1", "Text2", this gets much harder.
               }
           }
       }
   }

    // --- Main PDF Generation Logic ---
    // Generates the final PDF (either fillable or flattened static)
    async function generate8949(f8949Bytes, year, shortData, longData, isStatic = false) {
      const sourceDoc = await PDFDocument.load(f8949Bytes);
      const finalDoc = await PDFDocument.create(); // Create the target document we'll build
      const chunkSize = 14; // Assumed rows per page in the template

      // Process Short-Term Data
      if (shortData.length > 0) {
          for (let i = 0; i < shortData.length; i += chunkSize) {
              const chunk = shortData.slice(i, i + chunkSize);
                // Copy page 0 (Short-term template) from source to final doc
              const [copiedPage] = await finalDoc.copyPages(sourceDoc, [0]);
              finalDoc.addPage(copiedPage);
              // We need to fill data *after* copying the page into the finalDoc context
              await fillPageData(copiedPage, chunk);
              // Clone annotations to ensure fields are registered correctly in the finalDoc's AcroForm
              // This step might be redundant if fillPageData works directly on finalDoc's form,
              // but let's keep it for ensuring AcroForm field list is updated. Revisit if issues.
              // cloneAnnotations(copiedPage, sourceDoc); // Pass sourceDoc if needed by clone logic
          }
      } else {
           // Add a blank short-term page if no data
           const [copiedPage] = await finalDoc.copyPages(sourceDoc, [0]);
           finalDoc.addPage(copiedPage);
           // Optionally clone annotations even on blank pages if structure matters
           // cloneAnnotations(copiedPage, sourceDoc);
      }

      // Process Long-Term Data
      if (longData.length > 0) {
          for (let i = 0; i < longData.length; i += chunkSize) {
              const chunk = longData.slice(i, i + chunkSize);
              // Copy page 1 (Long-term template) from source to final doc
               const [copiedPage] = await finalDoc.copyPages(sourceDoc, [1]);
               finalDoc.addPage(copiedPage);
               await fillPageData(copiedPage, chunk);
               // cloneAnnotations(copiedPage, sourceDoc);
          }
      } else {
          // Add a blank long-term page if no data
          const [copiedPage] = await finalDoc.copyPages(sourceDoc, [1]);
          finalDoc.addPage(copiedPage);
           // cloneAnnotations(copiedPage, sourceDoc);
      }

      // --- Flatten if Static PDF is requested ---
      if (isStatic) {
        console.log("Flattening PDF...");
        try {
            const form = finalDoc.getForm(); // Get the form object
            if (form) { // Check if the form exists
                 // Ensure appearances are updated before flattening
                 form.updateFieldAppearances(); // Consider calling this explicitly if needed
                 form.flatten({ updateFieldAppearances: true }); // Call flatten on the form object
                 console.log("Flattening complete.");
             } else {
                 console.warn("No form found in the document to flatten.");
             }
        } catch (flattenError) {
            console.error("Error during flattening:", flattenError);
            alert(`Warning: Could not flatten the PDF. The downloaded file might still be editable or incomplete. Error: ${flattenError.message}`);
            // Even if flattening fails, try to save the filled (but not flattened) version
        }
      } else {
           // Ensure NeedAppearances might be needed for fillable forms if fields were modified
           // pdf-lib usually handles this, but explicitly setting it can sometimes help
           try {
               const form = finalDoc.getForm();
               if(form) {
                    form.acroForm.dict.set(PDFName.of('NeedAppearances'), finalDoc.context.obj(true));
               }
           } catch(e) {
               console.warn("Could not set NeedAppearances flag.", e);
           }
      }

      // Define filename based on output type
      const filename = `f8949_${year}_${isStatic ? 'static' : 'filled'}.pdf`;
      console.log(`Saving PDF as: ${filename}`);

      // Save the final document (now potentially flattened)
      // The save operation happens regardless of flattening success/failure in the catch block
      return finalDoc.save().then(data => new File([data.buffer], filename, { type: 'application/pdf' }));
    }

    // --- Helper Functions ---
    // Triggers browser download for a file object
    function download(file) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(file);
      a.download = file.name;
      document.body.appendChild(a); // Append anchor to body
      a.click();
      document.body.removeChild(a); // Clean up
      URL.revokeObjectURL(a.href); // Release object URL
    }

    // Parses a CSV file using PapaParse
    async function parseCsv(file, hasHeaders) {
      return new Promise((resolve, reject) => {
        if (!file || !(file instanceof File)) {
           return reject(new Error("Invalid file provided for parsing."));
        }
        Papa.parse(file, {
          header: false, // We handle headers manually if present
          skipEmptyLines: 'greedy',
          complete: (results) => {
              if (results.errors && results.errors.length > 0) {
                 return reject(new Error(`CSV Parsing Error (${results.errors[0].code}): ${results.errors[0].message} on row ${results.errors[0].row}`));
              }
              let data = results.data;
              if (hasHeaders && data.length > 0) {
                data.shift(); // Remove header row
              }
              // Standardize row length (ensure 8 columns)
              const expectedColumns = 8;
              const standardizedData = data
                 .filter(row => Array.isArray(row) && row.some(cell => cell !== null && cell !== undefined && cell !== '')) // Filter out completely empty rows
                 .map(row => {
                    const newRow = [...row];
                    while (newRow.length < expectedColumns) {
                        newRow.push(''); // Pad with empty strings
                    }
                    return newRow.slice(0, expectedColumns); // Truncate if too long
               });
              resolve(standardizedData);
          },
          error: (error) => {
              reject(error);
          }
        });
      });
    }

    // --- Event Listeners ---
    // Template Download Link
    document.querySelector('#template-link').addEventListener('click', e => {
      e.preventDefault();
      const csv = '"Description of property","Date acquired","Date sold or disposed of","Proceeds (sales price)","Cost or other basis","Code(s) from instructions","Amount of adjustment","Gain or (loss)"';
      const encoded = new TextEncoder().encode(csv);
      const file = new File([encoded], 'template.csv', { type: 'text/csv;charset=utf-8' });
      download(file);
    });

    // Form Submission Handler
    formElement.addEventListener('submit', async (e) => {
      e.preventDefault();

      if (formElement.hasAttribute('data-submitting')) {
        return;
      }
      formElement.setAttribute('data-submitting', '');
      spinner.style.display = 'inline-block';
      let pdfGenerated = false;

      try {
        const formData = new FormData(formElement);
        const year = formData.get('year');
        const shortFile = formData.get('short');
        const longFile = formData.get('long');
        const hasHeaders = formData.get('headers') === 'on';
        const isStatic = formData.get('format') === 'static'; // Determine if static (flattened) output needed

        if (!shortFile || shortFile.size === 0 || !longFile || longFile.size === 0) {
            throw new Error('Please select both short-term and long-term CSV files.');
        }

        console.log('Parsing CSV files...');
        const [shortData, longData] = await Promise.all([
          parseCsv(shortFile, hasHeaders),
          parseCsv(longFile, hasHeaders)
        ]);
        console.log(`Parsed ${shortData.length} short-term rows, ${longData.length} long-term rows.`);

        // --- Fetch Template ---
        const templateUrl = `./forms/f8949--${year}.pdf`;
        console.log(`Fetching template: ${templateUrl}`);
        const response = await fetch(templateUrl);
        console.log(`Fetch response status: ${response.status}`);
        if (!response.ok) {
           throw new Error(`Failed to fetch PDF template: ${response.status} ${response.statusText}. Ensure '${templateUrl}' exists.`);
        }
        const f8949Bytes = await response.arrayBuffer();
        console.log(`Template fetched (${f8949Bytes.byteLength} bytes).`);

        // --- Generate PDF (Fillable or Flattened) ---
        console.log(`Generating ${isStatic ? 'static (flattened)' : 'fillable'} PDF...`);
        // generate8949 now handles both cases based on isStatic flag
        const finalPdfFile = await generate8949(f8949Bytes, year, shortData, longData, isStatic);

        if (finalPdfFile instanceof File) {
            console.log('PDF generated successfully:', finalPdfFile.name);
            download(finalPdfFile);
            pdfGenerated = true;
        } else {
            throw new Error('PDF generation failed to return a valid file.');
        }

      } catch (error) {
        console.error('Error during form processing:', error);
        alert(`An error occurred: ${error.message || 'Please check console for details.'}`);

      } finally {
        console.log('Form processing finished. Cleaning up...');
        spinner.style.display = 'none';
        formElement.removeAttribute('data-submitting');
        if (pdfGenerated) {
            console.log("PDF download initiated.");
        } else {
             console.log("PDF generation/download did not complete successfully.");
        }
      }
    });

  </script>
</body>
</html>