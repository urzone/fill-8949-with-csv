<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Web app that fills IRS Form 8949 with data from a CSV file.">
  <meta property="og:title" content="Fill IRS Form 8949 with CSV">
  <meta property="og:description" content="Web app that fills IRS Form 8949 with data from a CSV file.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://fill-8949.ardis.lu/">
  <link rel="preconnect" href="https://rsms.me/">
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
  <link rel="icon" href="data:,">
  <link rel="preload" href="https://rsms.me/inter/font-files/InterVariable.woff2?v=4.1" crossorigin as="font">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/tslib@1.14.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/pako@1.0.11/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/@pdf-lib/standard-fonts@1.0.0/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/@pdf-lib/upng@1.0.1/+esm">
  <title>Fill IRS Form 8949 with CSV</title>
  <style>
    :root {
      font-family: 'Inter', sans-serif;
    }

    @supports (font-variation-settings: normal) {
      :root {
        font-family: 'Inter var', sans-serif;
      }
    }

    body {
      background: hsl(216deg 50% 90%);
      color: hsl(216deg 50% 10%);
      min-block-size: 100dvb;
      inline-size: calc(100% - 32px);
      margin-inline: auto;
      margin-block: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 16px;
    }

    section.info {
      margin-block-start: 16px;
    }

    p {
      margin: 0;
    }

    h1 {
      margin: 0;
      margin-block-end: 24px;
      font-size: 2rem;
    }

    .source {
      margin-block-start: 24px;
    }

    a {
      color: hsl(216deg 50% 40%);
      font-weight: 700;
      text-decoration: none;
    }

    a:hover,
    a:focus {
      text-decoration: underline 0.1em;
      text-underline-offset: 0.15em;
    }

    main {
      margin-block-end: 16px;
    }

    svg {
      block-size: 1rem;
      inline-size: 1rem;
      /* Optically center the SVG */
      transform: translateY(3px);
    }

    form {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    label {
      inline-size: fit-content;
    }

    label:not([for="headers"]) {
      /* Expand clickable area to cover flex gap */
      padding-block-end: 8px;
      margin-block-end: -8px;
    }

    label[for="headers"] {
      padding-inline-start: 4px;
      margin-inline-start: -4px;
    }

    input {
      inline-size: fit-content;
      font-size: 1rem;
    }

    input[type="checkbox"] {
      width: 16px;
      aspect-ratio: 1;
      margin: 0;
    }

    select,
    button,
    input::file-selector-button {
      inline-size: fit-content;
      color: inherit;
      font-size: 1rem;
      border: 1px solid hsl(216deg 50% 50%);
      border-radius: 4px;
      padding: 4px 8px;
      transition: filter 400ms;
    }

    :is(label, select, input, button, input::file-selector-button):is(:hover, :focus) {
      cursor: pointer;
      filter: brightness(105%);
      transition: filter 200ms;
    }

    [data-submitting] button {
      cursor: not-allowed;
      background: hsl(216deg 5% 85% / 0.9);
      filter: unset;
      transition: unset;
    }

    ol {
      margin: 0;
      margin-block-end: 24px;
    }

    .card {
      align-self: center;
      inline-size: min(60ch, 100% - 32px);
      background: hsl(216deg 50% 85%);
      border: 1px solid hsl(216deg 50% 50%);
      border-radius: 4px;
      padding: 16px;
    }

    .disclaimer,
    .privacy,
    .directions {
      color: hsl(216deg 50% 25%);
    }

    .inline-container {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .inline-spinner {
      display: none;
      box-sizing: border-box;
      block-size: 1em;
      inline-size: 1em;
      border: 0.25em solid transparent;
      border-block-start: 0.25em solid hsl(216deg 50% 40%);
      border-radius: 50%;
      animation: spin 1s infinite;
    }

    @keyframes spin {
      100% {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <section class="info card">
    <h1>Fill IRS Form 8949 with CSV</h1>
    <p class="disclaimer"><b>Disclaimer:</b> the author of this tool is not responsible for any errors or omissions, or for the results obtained from the use of this tool. All outputs are provided "as is", with no guarantee of completeness, accuracy, or of the results obtained from the use of this tool, and without warranty of any kind. The output from this tool is provided with the understanding that the author is not herein engaged in rendering legal, accounting, tax, or other professional advice and services.</p>
    <p class="privacy"><b>Privacy:</b> the CSV parsing and PDF filling operations occur in your web browser. Your CSV data does not leave your computer.</p>
    <p class="source"><a href="https://github.com/ardislu/fill-8949-with-csv">Click here to view this tool's source code on GitHub.</a></p>
  </section>

  <main class="card">
    <p class="directions"><b>Directions:</b>
    <ol>
      <li>Download two copies of the CSV template (<a id="template-link" href="#"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" alt="">
            <path d="M12 17V3" />
            <path d="m6 11 6 6 6-6" />
            <path d="M19 21H5" />
          </svg>template.csv</a>).</li>
      <li>Fill the templates with data to populate the tables on page 1 (short-term transactions) and page 2 (long-term transactions) of <a href="https://www.irs.gov/form8949">IRS Form 8949</a>.</li>
      <li>Select the filled CSV templates in the file pickers below.</li>
      <li>Click "Download Filled Form 8949" to download a copy of Form 8949 with the CSV data filled into it.</li>
    </ol>
    </p>
    <form>
      <label for="year">Tax year</label>
      <select id="year" name="year">
        <option value="2024">2024</option>
        <option value="2023">2023</option>
        <option value="2022">2022</option>
        <option value="2021">2021</option>
        <option value="2020">2020</option>
        <option value="2019">2019</option>
        <option value="2018">2018</option>
        <option value="2017">2017</option>
        <option value="2016">2016</option>
        <option value="2015">2015</option>
        <option value="2014">2014</option>
        <option value="2013">2013</option>
      </select>

      <label for="short">Short-term transactions</label>
      <input type="file" id="short" name="short" accept="text/csv" required>

      <label for="long">Long-term transactions</label>
      <input type="file" id="long" name="long" accept="text/csv" required>

      <div class="inline-container">
        <input type="checkbox" id="headers" name="headers" checked>
        <label for="headers">Data has headers</label>
      </div>

      <div class="inline-container">
        <button>Download Filled Form 8949</button>
        <span class="inline-spinner"></span>
      </div>
    </form>
  </main>

  <script type="module">
    import Papa from 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/+esm';
    import { PDFArray, PDFDict, PDFDocument, PDFName, PDFString } from 'https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm';

    const button = document.querySelector('button');
    const spinner = document.querySelector('span.inline-spinner');

    // Use a custom id generator instead of crypto.randomUUID() to reduce PDF file size
    const annotationIds = (function* () {
      let i = 0;
      while (true) {
        yield `f${i}`; // Must be unique within the PDF
        i++;
      }
    })();

    // Duplicate all annotations exactly, except for the "T" key. The "T" key ("text label") is used
    // as a unique identifier for the annotation and must be updated or else all annotations with
    // the same "T" key will have the same value.
    // Original code from: https://github.com/Hopding/pdf-lib/issues/151
    function cloneAnnotations(page) {
      const form = page.doc.catalog.lookup(PDFName.of('AcroForm'), PDFDict);
      const fields = form.lookup(PDFName.of('Fields'), PDFArray);
      const annotations = page.node.Annots();
      if (annotations) { // Check if annotations exist
        for (let i = 0; i < annotations.size(); i++) {
          const a = annotations.lookup(i, PDFDict);
          // Only clone if it's likely a form field annotation (Widget type)
          if (a.lookup(PDFName.Type) === PDFName.Annot && a.lookup(PDFName.Subtype) === PDFName.Widget) {
              const clonedA = a.clone(page.doc.context); // Clone the annotation dictionary
              clonedA.set(PDFName.of('T'), PDFString.of(annotationIds.next().value)); // Set unique T key
              fields.push(clonedA.ref); // Pushes the indirect reference to the object
          }
        }
      }
    };

    async function generatePage(originalDoc, data, type) {
      // Copy the correct template page (0 for short, 1 for long)
      const [page] = type === 'short' ? await originalDoc.copyPages(originalDoc, [0]) : await originalDoc.copyPages(originalDoc, [1]);

      // Clone the annotations from the original template page onto the new page instance
      // This ensures the new page has the fields array populated correctly for filling
       cloneAnnotations(page); // Corrected: Operate on the newly copied page

      const form = originalDoc.getForm(); // Get the form object once

      let cellNumber = 0;
      const offset = 5; // Offset based on visual inspection/debugging (may need adjustment for different forms/years)
      const fieldsOnPage = form.getFields().filter(field => field.acroField.getParent() === page.node.Annots()); // Attempt to get fields associated with this page, might not be direct in pdf-lib

      // Get all fields associated with the AcroForm,
      // We'll rely on the implicit order matching the visual layout and the cloned 'T' keys for *potential* future mapping,
      // but primarily use index based filling as before after cloning.
      // Note: pdf-lib might fill based on the /Fields array order added by cloneAnnotations.
      const allFields = form.getFields();

      // We need to find the indices in the main 'Fields' array that correspond to the *cloned* annotations
       // for this specific page. This is tricky as pdf-lib doesn't maintain a direct page->field mapping post-cloning.
       // The cloneAnnotations function adds the *cloned* annots to the end of the main /Fields array.
       // If pages are generated sequentially, we might infer the field indices based on how many were added previously.
       // Let's assume cloneAnnotations adds 14*8 (rows*cols) + some other fields per page? Needs verification.
       // For simplicity, let's stick to the lookup-by-index-on-page-annotations approach, assuming pdf-lib maps V correctly upon save.

      const annots = page.node.Annots(); // Get the annotations array *of the copied page*

       if (annots) { // Ensure annotations exist on the copied page
          let fieldIndexOnPage = 0; // Keep track of potential *widget* annotations on the page
          for (let annotIndex = 0; annotIndex < annots.size(); annotIndex++) {
                const annotDict = annots.lookup(annotIndex, PDFDict);
                // Check if it's a Widget annotation (likely a field)
                if (annotDict.lookup(PDFName.Subtype) === PDFName.Widget) {
                  // We are looking for the specific table cells, assuming they start after an offset
                  if(fieldIndexOnPage >= offset && cellNumber < data.length * data[0].length) { // Check we are within data bounds
                    const rowIndex = Math.floor(cellNumber / data[0].length);
                    const colIndex = cellNumber % data[0].length;
                    if (rowIndex < data.length && colIndex < data[rowIndex].length) {
                        const cellValue = data[rowIndex][colIndex];
                        // Set the Value ('/V') directly on the annotation dictionary
                        // PDFString.of() handles encoding correctly
                       annotDict.set(PDFName.of('V'), PDFString.of(cellValue || '')); // Use empty string if cell is null/undefined
                       annotDict.set(PDFName.of('AP'), null); // Remove existing appearance stream, pdf-lib will generate on save/flatten
                     }
                    cellNumber++;
                  }
                  fieldIndexOnPage++; // Increment only for widget annotations
               }
            }
        }

      return page;
    }

    async function generate8949(f8949Bytes, year, shortData, longData) {
      // Load the original IRS Form 8949 PDF bytes
      const f8949 = await PDFDocument.load(f8949Bytes, {
           updateMetadata: false, // May help prevent issues with metadata conflicts
      });
      const pagePromises = []; // To hold promises for generated pages
      const chunkSize = 14; // Number of transaction rows per PDF page

       // Initialize AcroForm Fields if not present (might be needed if original is pure XFA)
       // This part might require more checks depending on the source PDF structure
       const catalog = f8949.catalog;
       let acroForm = catalog.lookup(PDFName.of('AcroForm'), PDFDict);
       if (!acroForm) {
           acroForm = f8949.context.obj({ Type: 'AcroForm', Fields: [] });
           catalog.set(PDFName.of('AcroForm'), acroForm);
        } else if (!acroForm.has(PDFName.of('Fields'))) {
           acroForm.set(PDFName.of('Fields'), f8949.context.obj([]));
       }

      // Generate pages for short-term transactions
      for (let i = 0; i < shortData.length; i += chunkSize) {
        const chunk = shortData.slice(i, i + chunkSize); // Get a chunk of 14 rows
        // Generate a page for this chunk, copying the short-term template (page 0)
        pagePromises.push(generatePage(f8949, chunk, 'short'));
      }
      // If there are no short-term transactions, add a blank short-term page by copying
      if (shortData.length === 0) {
        const [blankShortPage] = await f8949.copyPages(f8949, [0]);
         cloneAnnotations(blankShortPage); // Clone annotations even for blank pages for consistency
        pagePromises.push(Promise.resolve(blankShortPage)); // Resolve promise immediately
      }

      // Generate pages for long-term transactions
      for (let i = 0; i < longData.length; i += chunkSize) {
        const chunk = longData.slice(i, i + chunkSize); // Get a chunk of 14 rows
        // Generate a page for this chunk, copying the long-term template (page 1)
        pagePromises.push(generatePage(f8949, chunk, 'long'));
      }
      // If there are no long-term transactions, add a blank long-term page by copying
      if (longData.length === 0) {
         const [blankLongPage] = await f8949.copyPages(f8949, [1]);
         cloneAnnotations(blankLongPage); // Clone annotations even for blank pages
         pagePromises.push(Promise.resolve(blankLongPage)); // Resolve promise immediately
      }

      // Wait for all page generation promises to resolve
      const pages = await Promise.all(pagePromises);

       // Add all the newly generated (and filled) pages to the document *before* removing old ones
      for (const page of pages) {
        f8949.addPage(page);
      }

      // Remove the original 2 template pages from the PDF
      // Important: Remove pages *after* adding new ones and potentially cloning resources they need.
      f8949.removePage(0);
      f8949.removePage(0); // Remove the first page again, as indices shift after the first removal

      // --- Modification Start ---
      // Get the PDF's form object
      const form = f8949.getForm();

       // Attempt to update appearance streams before flattening
       try {
           form.updateFieldAppearances();
       } catch (e) {
           console.warn("Could not update field appearances, flattening might use default appearances.", e);
       }

      // Flatten the form fields, making them static content and removing XFA/AcroForm structures
      try {
        form.flatten();
      } catch (e) {
         console.error("Error during form flattening:", e);
         // Decide how to handle: maybe alert user, maybe save unflattened?
         // Saving unflattened as fallback:
         // return f8949.save({ useObjectStreams: false }).then(data => new File([data.buffer], `f8949_${year}_filled_unflattened.pdf`, { type: 'application/pdf' }));
         throw new Error("Failed to flatten PDF form."); // Or re-throw error
      }
      // --- Modification End ---

      // Save the modified PDF document into bytes
      // Using useObjectStreams: false can sometimes improve compatibility
      return f8949.save({ useObjectStreams: false }).then(data => new File([data.buffer], `f8949_${year}_filled.pdf`, { type: 'application/pdf' }));
    }

    function download(file) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(file);
      a.download = file.name;
      a.click();
      URL.revokeObjectURL(a.href); // Clean up the object URL
    }

    async function parseCsv(file, hasHeaders) {
      const csv = await new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: false,
          skipEmptyLines: 'greedy',
          complete: resolve,
          error: reject
        });
      });

      const data = csv.data;
      if (hasHeaders && data.length > 0) { // Check if data exists before shifting
        data.shift();
      }
      return data;
    }

    document.querySelector('#template-link').addEventListener('click', e => {
      e.preventDefault();
      const csv = 'Description of property,Date acquired,Date sold or disposed of,Proceeds (sales price),Cost or other basis,Code(s) from instructions,Amount of adjustment,Gain or (loss)';
      const encoded = new TextEncoder().encode(csv);
      const file = new File([encoded], 'template.csv', { type: 'text/csv' });
      download(file);
    });

    document.querySelector('form').addEventListener('submit', async e => {
      e.preventDefault();

      if (e.target.hasAttribute('data-submitting')) {
        return;
      }
      e.target.setAttribute('data-submitting', '');
      spinner.style.display = 'inline-block';
      button.disabled = true; // Disable button

      const formElement = e.target; // Use formElement for clarity
      const formData = new FormData(formElement); // Use correct variable name
      const year = formData.get('year');
      const shortFile = formData.get('short');
      const longFile = formData.get('long');
      const hasHeaders = formData.get('headers') === 'on';

      try {
        const [f8949Bytes, shortData, longData] = await Promise.all([
          // Ensure the path is correct for fetching the PDF form
          fetch(`./forms/f8949--${year}.pdf`).then(r => {
             if (!r.ok) { throw new Error(`Failed to fetch form for year ${year}: ${r.statusText}`); }
             return r.arrayBuffer();
          }),
          parseCsv(shortFile, hasHeaders),
          parseCsv(longFile, hasHeaders)
        ]);

        const filledPdfFile = await generate8949(f8949Bytes, year, shortData, longData);
        download(filledPdfFile);

      } catch (error) {
          console.error("Error processing form:", error);
          alert(`An error occurred: ${error.message}\nPlease check console for details.`); // Inform user
      } finally {
          // Re-enable form regardless of success or failure
          spinner.style.display = 'none';
          formElement.removeAttribute('data-submitting');
          button.disabled = false; // Re-enable button
      }
    });
  </script>
</body>

</html>