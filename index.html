<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Web app that fills IRS Form 8949 with data from a CSV file.">
  <meta property="og:title" content="Fill IRS Form 8949 with CSV">
  <meta property="og:description" content="Web app that fills IRS Form 8949 with data from a CSV file.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://form8949.urz.one/">

  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/tslib@1.14.1/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/pako@1.0.11/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/@pdf-lib/standard-fonts@1.0.0/+esm">
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/@pdf-lib/upng@1.0.1/+esm">
  <title>Fill IRS Form 8949 with CSV</title>
  <style>
    /* CSS Styles remain the same as provided previously */
    :root {
      --primary: #1a4d7c;
      --primary-light: #2975b9;
      --primary-dark: #0f3155;
      --secondary: #f8f9fa;
      --accent: #4cc9f0;
      --text: #333;
      --text-light: #6c757d;
      --success: #28a745;
      --error: #dc3545;
      --border-radius: 8px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
      font-family: 'Inter', sans-serif;
    }

    @supports (font-variation-settings: normal) {
      :root {
        font-family: 'Inter var', sans-serif;
      }
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      color: var(--text);
      min-height: 100vh;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      line-height: 1.6;
    }

    .container {
      width: min(1000px, 100%);
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 2rem;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 1rem;
      color: var(--primary);
      line-height: 1.2;
    }

    .subtitle {
      color: var(--text-light);
      font-size: 1.2rem;
      max-width: 600px;
      margin: 0 auto;
    }

    .card {
      background: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 2rem;
      margin-bottom: 2rem;
      transition: var(--transition);
    }

    .card:hover {
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
    }

    .disclaimer, .privacy {
      background: #f8f9fa;
      border-left: 4px solid var(--primary);
      padding: 1rem;
      margin: 1.5rem 0;
      border-radius: 0 var(--border-radius) var(--border-radius) 0;
    }

    .disclaimer b, .privacy b {
      color: var(--primary);
      display: block;
      margin-bottom: 0.5rem;
    }

    .steps {
      counter-reset: step;
      margin: 2rem 0;
    }

    .step {
      display: flex;
      margin-bottom: 1.5rem;
      padding: 0 0 0 3rem;
      position: relative;
    }

    .step:before {
      counter-increment: step;
      content: counter(step);
      position: absolute;
      left: 0;
      top: 0;
      background: var(--primary);
      color: white;
      width: 2rem;
      height: 2rem;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }

    .form-container {
      background: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 2rem;
    }

    .form-group {
      margin-bottom: 1.5rem;
    }

    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: var(--primary-dark);
    }

    select, input[type="file"] {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border: 1px solid #ced4da;
      border-radius: var(--border-radius);
      background-color: #fff;
      transition: var(--transition);
    }

    select {
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%231a4d7c' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 1rem center;
      background-size: 1em;
      padding-right: 2.5rem;
    }

    input[type="file"] {
      padding: 0.5rem;
    }

    input[type="file"]::file-selector-button {
      font-size: 0.9rem;
      padding: 0.5rem 1rem;
      margin-right: 1rem;
      border-radius: var(--border-radius);
      background-color: var(--secondary);
      border: 1px solid #ced4da;
      color: var(--text);
      cursor: pointer;
      transition: var(--transition);
    }

    input[type="file"]::file-selector-button:hover {
      background-color: #e2e6ea;
    }

    .checkbox-group, .radio-group {
      display: flex;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    .radio-group {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
    }

    .radio-option {
      display: flex;
      align-items: center;
    }

    input[type="checkbox"], input[type="radio"] {
      margin-right: 0.5rem;
      width: 1.25rem;
      height: 1.25rem;
      accent-color: var(--primary);
    }

    button {
      background-color: var(--primary);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: var(--transition);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    button:hover {
      background-color: var(--primary-light);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    [data-submitting] button {
      cursor: not-allowed;
      background-color: var(--text-light);
      opacity: 0.7;
      transform: none;
    }

    .button-container {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 1rem;
    }

    .download-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--primary);
      font-weight: 600;
      text-decoration: none;
      transition: var(--transition);
    }

    .download-link:hover {
      color: var(--primary-light);
      text-decoration: underline;
    }

    .download-link svg {
      transition: var(--transition);
    }

    .download-link:hover svg {
      transform: translateY(2px);
    }

    .source {
      margin-top: 1.5rem;
      text-align: center;
    }

    .source a {
      color: var(--primary);
      font-weight: 500;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .source a:hover {
      color: var(--primary-light);
      text-decoration: underline;
    }

    .spinner {
      display: none;
      width: 1.5rem;
      height: 1.5rem;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-left: 0.75rem;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    footer {
      margin-top: 3rem;
      text-align: center;
      color: var(--text-light);
      font-size: 0.9rem;
    }

    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }

      .card, .form-container {
        padding: 1.5rem;
      }

      h1 {
        font-size: 2rem;
      }

      .step {
        padding-left: 2.5rem;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>IRS Form 8949 Filler</h1>
      <p class="subtitle">Easily fill IRS Form 8949 with your CSV data</p>
    </header>

    <section class="card">
      <div class="disclaimer">
        <b>Disclaimer</b>
        <p>The author of this tool is not responsible for any errors or omissions, or for the results obtained from the use of this tool. All outputs are provided "as is", with no guarantee of completeness, accuracy, or of the results obtained from the use of this tool, and without warranty of any kind. The output from this tool is provided with the understanding that the author is not herein engaged in rendering legal, accounting, tax, or other professional advice and services.</p>
      </div>

      <div class="privacy">
        <b>Privacy</b>
        <p>The CSV parsing and PDF filling operations occur in your web browser. Your CSV data does not leave your computer.</p>
      </div>
    </section>

    <div class="form-container">
      <div class="steps">
        <div class="step">
          <div>
            <h3>Download CSV Templates</h3>
            <p>Download two copies of the CSV template for short-term and long-term transactions.</p>
            <a href="#" id="template-link" class="download-link">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
              </svg>
              template.csv
            </a>
          </div>
        </div>

        <div class="step">
          <div>
            <h3>Fill the Templates</h3>
            <p>Fill the templates with data to populate the tables on page 1 (short-term transactions) and page 2 (long-term transactions) of <a href="https://www.irs.gov/form8949" target="_blank">IRS Form 8949</a>.</p>
          </div>
        </div>

        <div class="step">
          <div>
            <h3>Upload and Generate</h3>
            <p>Select the filled CSV templates and click "Generate Filled Form" to download your customized IRS Form 8949.</p>
          </div>
        </div>
      </div>

      <form>
        <div class="form-group">
          <label for="year">Tax Year</label>
          <select id="year" name="year">
            <option value="2024">2024</option>
            <option value="2023">2023</option>
            <option value="2022">2022</option>
            <option value="2021">2021</option>
            <option value="2020">2020</option>
            <option value="2019">2019</option>
            <option value="2018">2018</option>
            <option value="2017">2017</option>
            <option value="2016">2016</option>
            <option value="2015">2015</option>
            <option value="2014">2014</option>
            <option value="2013">2013</option>
          </select>
        </div>

        <div class="form-group">
          <label for="short">Short-term Transactions CSV</label>
          <input type="file" id="short" name="short" accept="text/csv" required>
        </div>

        <div class="form-group">
          <label for="long">Long-term Transactions CSV</label>
          <input type="file" id="long" name="long" accept="text/csv" required>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="headers" name="headers" checked>
          <label for="headers">CSV data has headers</label>
        </div>

        <div class="form-group">
          <label>Output Format</label>
          <div class="radio-group">
            <div class="radio-option">
              <input type="radio" id="format-form" name="format" value="form" checked>
              <label for="format-form">Form with Fields (Editable)</label>
            </div>
            <div class="radio-option">
              <input type="radio" id="format-static" name="format" value="static">
              <label for="format-static">Static PDF (Compatible with all viewers)</label>
            </div>
          </div>
        </div>

        <div class="button-container">
          <button type="submit">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
            Generate Filled Form
          </button>
          <div class="spinner"></div>
        </div>

        <div class="source">
          <a href="https://github.com/ardislu/fill-8949-with-csv" target="_blank">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg>
            View source code on GitHub
          </a>
        </div>
      </form>
    </div>

    <footer>
      <p>&copy; 2025 IRS Form 8949 Filler Tool</p> <!-- Note: Year might need update -->
    </footer>
  </div>

  <script type="module">
    import Papa from 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/+esm';
    import { PDFArray, PDFDict, PDFDocument, PDFName, PDFString, rgb, StandardFonts } from 'https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm';

    const button = document.querySelector('button');
    const spinner = document.querySelector('.spinner');
    const formElement = document.querySelector('form'); // Reference the form element

    // Use a custom id generator instead of crypto.randomUUID() to reduce PDF file size
    const annotationIds = (function* () {
      let i = 0;
      while (true) {
        yield `f${i}`; // Must be unique within the PDF
        i++;
      }
    })();

    // Duplicate all annotations exactly, except for the "T" key. The "T" key ("text label") is used
    // as a unique identifier for the annotation and must be updated or else all annotations with
    // the same "T" key will have the same value.
    // Original code from: https://github.com/Hopding/pdf-lib/issues/151
    function cloneAnnotations(page) {
      // Check if AcroForm exists, if not, return (might happen on newly created pages)
      const acroFormRef = page.doc.catalog.get(PDFName.of('AcroForm'));
      if (!acroFormRef) return;
      const form = page.doc.context.lookup(acroFormRef);
      if (!(form instanceof PDFDict)) return; // Ensure it's a dictionary

      const fieldsRef = form.get(PDFName.of('Fields'));
      if (!fieldsRef) {
          form.set(PDFName.of('Fields'), page.doc.context.obj([])); // Create if doesn't exist
      }
      const fields = page.doc.context.lookup(fieldsRef);
      if (!(fields instanceof PDFArray)) {
           console.warn("Fields is not an array, cannot clone annotations.");
           return; // Should be an array
      }

      const annotsRef = page.node.get(PDFName.of('Annots'));
      if (!annotsRef) return; // No annotations on page
      const annotations = page.doc.context.lookup(annotsRef);
      if (!(annotations instanceof PDFArray)) return; // Annots should be an array

      for (let i = 0; i < annotations.size(); i++) {
        const annotRef = annotations.get(i);
        const a = page.doc.context.lookup(annotRef);
        if (a instanceof PDFDict) { // Ensure it's a dictionary
         // Check if it's a Widget annotation (form field)
         if (a.lookup(PDFName.of('Subtype')) === PDFName.of('Widget')) {
            a.set(PDFName.of('T'), PDFString.of(annotationIds.next().value));
            fields.push(annotRef);
         }
        }
      }
    };

    async function generatePage(f8949, data, type) {
      const originalPages = await f8949.copyPages(f8949, type === 'short' ? [0] : [1]);
      const [page] = originalPages;
      cloneAnnotations(page);

      let cellNumber = 0;
      const offset = 5; // To skip to the table annotations (adjust if form changes)
      const annotsRef = page.node.get(PDFName.of('Annots'));
      if (!annotsRef) return page; // No annotations, return the copied page

      const annots = f8949.context.lookup(annotsRef);
      if (!(annots instanceof PDFArray)) return page; // Should be an array

      // Keep track of annotation indices we successfully update
      const updatedIndices = new Set();

      // Try to fill based on expected number of fields per row (8)
      const fieldsPerRow = 8;
      let currentFieldIdx = offset;

      for (const row of data) {
        for (let colIdx = 0; colIdx < row.length; colIdx++) {
            // Try to find the correct annotation ref and dict
            let a = null;
            let actualIndex = -1;

            // Search for the next available widget annotation after the offset
            for(let searchIdx = currentFieldIdx; searchIdx < annots.size(); searchIdx++) {
                const potentialAnnotRef = annots.get(searchIdx);
                const potentialAnnot = f8949.context.lookup(potentialAnnotRef);
                if (potentialAnnot instanceof PDFDict && potentialAnnot.lookup(PDFName.of('Subtype')) === PDFName.of('Widget') && !updatedIndices.has(searchIdx)) {
                    a = potentialAnnot;
                    actualIndex = searchIdx;
                    break; // Found the next one
                }
            }

            if (a && actualIndex !== -1) {
               const cellValue = row[colIdx] || ''; // Ensure value is string, use empty if null/undefined
               // Only set 'V' if it's a Text field. Other widget types might need different keys.
               const fieldType = a.get(PDFName.of('FT'));
               if (fieldType === PDFName.of('Tx')) { // Check if it's a Text field
                    a.set(PDFName.of('V'), PDFString.nonLatin(String(cellValue))); // Use nonLatin for wider char support
               }
               updatedIndices.add(actualIndex); // Mark as updated
               currentFieldIdx = actualIndex + 1; // Start next search from here
            }
             // Limit to the expected number of columns in the form's row
            if (colIdx >= fieldsPerRow - 1) break;
        }
      }
      return page;
    }

    async function generateStaticPDF(year, shortData, longData) {
      // Create a new PDF document from scratch
      const pdfDoc = await PDFDocument.create();
      const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
      const defaultColor = rgb(0, 0, 0);
      const grayColor = rgb(0.7, 0.7, 0.7);
      const fontSize = 9;
      const lineHeight = 12; // Slightly more than font size for spacing
      const pageHeight = 792; // Letter size height
      const pageWidth = 612; // Letter size width
      const margin = 40; // Slightly reduced margin for more space
      const tableTopMargin = 90; // Increased top margin for header/title
      const contentHeight = pageHeight - margin - tableTopMargin;
      const contentWidth = pageWidth - 2 * margin;

      // Define table structure
      const headers = [ // Adjusted headers slightly for potential wrapping
        'Description of property (Example: 100 sh. XYZ Co.)', // (a)
        'Date acquired (Mo., day, yr.)', // (b)
        'Date sold (Mo., day, yr.)', // (c)
        'Proceeds (sales price)', // (d)
        'Cost basis', // (e)
        'Code(s)', // (f)
        'Adjustment', // (g)
        'Gain/(loss)' // (h)
      ];

      // Approximate relative widths based on typical form layout
      const colWidths = [
          contentWidth * 0.28, // a
          contentWidth * 0.12, // b
          contentWidth * 0.12, // c
          contentWidth * 0.11, // d
          contentWidth * 0.11, // e
          contentWidth * 0.07, // f
          contentWidth * 0.09, // g
          contentWidth * 0.10, // h
      ].map(w => Math.floor(w)); // Ensure integer widths

      // Function to wrap text within a cell width
      const wrapText = (text, maxWidth, font, size) => {
        const words = String(text || '').split(' '); // Ensure text is a string
        const lines = [];
        let currentLine = words[0] || '';

        for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = font.widthOfTextAtSize(currentLine + " " + word, size);
            if (width < maxWidth) {
                currentLine += " " + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }
        lines.push(currentLine);
        return lines;
      };

      // Function to draw the table headers on a given page
      const drawHeaders = (page, yPos) => {
        let xPos = margin;
        const headerY = yPos + 2; // Position text slightly above the line
        page.drawLine({
            start: { x: margin, y: yPos },
            end: { x: pageWidth - margin, y: yPos },
            thickness: 1,
            color: defaultColor,
        });
        for(let i = 0; i < headers.length; i++) {
            const lines = wrapText(headers[i], colWidths[i] - 4, helveticaBold, fontSize); // Wrap headers too
            lines.forEach((line, lineIndex) => {
                 page.drawText(line, {
                    x: xPos + 2, // Indent slightly within cell
                    y: headerY - (lineIndex * lineHeight) - (lineHeight / 2) + (lines.length > 1 ? (lineHeight / 2) : 0), // Adjust Y for multi-line headers
                    size: fontSize,
                    font: helveticaBold,
                    color: defaultColor,
                 });
            });

            // Draw vertical lines for columns
            if (i < headers.length) {
                page.drawLine({
                    start: { x: xPos, y: yPos + lineHeight }, // Line starts from top of header row
                    end: { x: xPos, y: yPos - (lines.length * lineHeight) }, // Ends below potentially wrapped header
                    thickness: 0.5,
                    color: grayColor
                });
            }
            xPos += colWidths[i];
        }
        // Draw last vertical line
         page.drawLine({
            start: { x: xPos, y: yPos + lineHeight },
            end: { x: xPos, y: yPos - (wrapText(headers[headers.length-1], colWidths[headers.length-1]-4, helveticaBold, fontSize).length * lineHeight) },
            thickness: 0.5,
            color: grayColor
        });

        const headerHeight = Math.max(...headers.map((h, i) => wrapText(h, colWidths[i] - 4, helveticaBold, fontSize).length)) * lineHeight;
        page.drawLine({ // Line below headers
            start: { x: margin, y: yPos - headerHeight + 2 },
            end: { x: pageWidth - margin, y: yPos - headerHeight + 2 },
            thickness: 1,
            color: defaultColor,
        });
        return yPos - headerHeight; // Return the Y position below the header block
      };

      // Function to create a page and add standard elements
      const addPageWithHeaders = (title, part, boxChecked) => {
        let page = pdfDoc.addPage([pageWidth, pageHeight]);
        const yOffset = pageHeight - margin;

        // Main Title & Year
        page.drawText(`Form 8949`, { x: margin, y: yOffset, size: 16, font: helveticaBold });
        page.drawText(`Department of the Treasury`, { x: margin + 200, y: yOffset + 8, size: 8, font: helveticaFont });
        page.drawText(`Internal Revenue Service (${year})`, { x: margin + 200, y: yOffset, size: 8, font: helveticaFont });
         page.drawText(`Sales and Other Dispositions of Capital Assets`, { x: margin, y: yOffset - 18, size: 12, font: helveticaFont });

        // Part Title
        page.drawText(title, { x: margin, y: yOffset - 40, size: 12, font: helveticaBold });

         // Checkbox imitation (Optional - might need tweaking for exact look)
         const boxY = yOffset - 55;
         page.drawRectangle({ x: margin, y: boxY, width: 8, height: 8, borderColor: defaultColor, borderWidth: 1 });
         if (boxChecked) {
             page.drawText('X', { x: margin + 1, y: boxY, size: 8, font: helveticaBold });
         }
         page.drawText(part === 'I' ? 'Part I Short-Term. Transactions involving capital assets you held 1 year or less.' : 'Part II Long-Term. Transactions involving capital assets you held more than 1 year.', { x: margin + 12, y: boxY, size: 9, font: helveticaFont });
         page.drawText('You must check Box A, B, or C below. See instructions.', { x: margin, y: boxY - 12, size: 9, font: helveticaFont});

        // Draw headers and get starting Y for data rows
        let currentY = pageHeight - tableTopMargin;
        currentY = drawHeaders(page, currentY);
        return { page, currentY };
      };

      // Function to draw a single row's data
      const drawRow = (page, yPos, rowData) => {
          let xPos = margin;
          let maxLines = 1; // Track the max lines needed for this row

          // First pass: determine max lines needed
          rowData.forEach((cell, i) => {
              const lines = wrapText(cell, colWidths[i] - 4, helveticaFont, fontSize);
              if (lines.length > maxLines) {
                  maxLines = lines.length;
              }
          });
          const rowHeight = maxLines * lineHeight;

          // Check for page break BEFORE drawing
          if (yPos - rowHeight < margin) {
              return { needsNewPage: true, height: rowHeight }; // Signal that a new page is needed
          }

          // Second pass: draw the data
          const drawY = yPos - 4; // Position text slightly below the top line of the row cell
          rowData.forEach((cell, i) => {
              const lines = wrapText(cell, colWidths[i] - 4, helveticaFont, fontSize);
              lines.forEach((line, lineIndex) => {
                   page.drawText(line, {
                      x: xPos + 2,
                      y: drawY - (lineIndex * lineHeight),
                      size: fontSize,
                      font: helveticaFont,
                      color: defaultColor,
                   });
              });
              xPos += colWidths[i];
          });

           // Draw horizontal line below the row
           page.drawLine({
               start: { x: margin, y: yPos - rowHeight },
               end: { x: pageWidth - margin, y: yPos - rowHeight },
               thickness: 0.5,
               color: grayColor,
           });

          // Draw vertical lines for the row
          xPos = margin;
          for(let i = 0; i <= rowData.length; i++) {
              page.drawLine({
                  start: { x: xPos, y: yPos },
                  end: { x: xPos, y: yPos - rowHeight },
                  thickness: 0.5,
                  color: grayColor
              });
               if (i < rowData.length) xPos += colWidths[i];
          }

          return { newY: yPos - rowHeight, height: rowHeight, needsNewPage: false }; // Return new Y position and height used
      };

      // Process Short-Term Data
      if (shortData.length > 0) {
        let { page, currentY } = addPageWithHeaders('Part I - Short-term transactions', 'I', true); // Assuming Box A checked for simplicity
        for (const row of shortData) {
            let drawResult = drawRow(page, currentY, row);
            if (drawResult.needsNewPage) {
                // Add continuation text if needed
                // page.drawText('(Continued on next page)', { ... });
                let nextPageResult = addPageWithHeaders('Form 8949 (cont.) - Short-term', 'I', true);
                page = nextPageResult.page;
                currentY = nextPageResult.currentY;
                drawResult = drawRow(page, currentY, row); // Draw the row on the new page
            }
            currentY = drawResult.newY;
        }
      }

      // Process Long-Term Data
      if (longData.length > 0) {
        let { page, currentY } = addPageWithHeaders('Part II - Long-term transactions', 'II', true); // Assuming Box D equivalent if needed
         for (const row of longData) {
            let drawResult = drawRow(page, currentY, row);
            if (drawResult.needsNewPage) {
                // page.drawText('(Continued on next page)', { ... });
                let nextPageResult = addPageWithHeaders('Form 8949 (cont.) - Long-term', 'II', true);
                page = nextPageResult.page;
                currentY = nextPageResult.currentY;
                drawResult = drawRow(page, currentY, row);
            }
            currentY = drawResult.newY;
        }
      }

      // If both are empty, maybe add a single blank page? (Optional)
      if (shortData.length === 0 && longData.length === 0) {
         addPageWithHeaders('Form 8949 - No Data Provided', '', false);
      }

      // Save and return the file object
      const filename = `f8949_${year}_static.pdf`; // <-- Ensure .pdf extension
      return pdfDoc.save().then(data => new File([data.buffer], filename, { type: 'application/pdf' }));
    }

    async function generate8949(f8949Bytes, year, shortData, longData) {
      // This function is for the FILLABLE FORM path
      const f8949 = await PDFDocument.load(f8949Bytes);
      const pagePromises = [];
      const chunkSize = 14; // Assumes 14 rows per page in the template

      for (let i = 0; i < shortData.length; i += chunkSize) {
        const chunk = shortData.slice(i, i + chunkSize);
        pagePromises.push(generatePage(f8949, chunk, 'short'));
      }
      // Add a blank short-term page if no short-term data exists but long-term does,
      // or if both are empty to ensure structure. Only skip if long-term exists AND short is empty.
      // Simplification: Always add at least one page copy for each part if no data.
      if (shortData.length === 0) {
        const [blankPage] = await f8949.copyPages(f8949, [0]);
        cloneAnnotations(blankPage); // Important for unique field names if needed later
        pagePromises.push(Promise.resolve(blankPage));
      }

      for (let i = 0; i < longData.length; i += chunkSize) {
        const chunk = longData.slice(i, i + chunkSize);
        pagePromises.push(generatePage(f8949, chunk, 'long'));
      }
      if (longData.length === 0) {
         const [blankPage] = await f8949.copyPages(f8949, [1]);
         cloneAnnotations(blankPage);
         pagePromises.push(Promise.resolve(blankPage));
      }

      const pages = await Promise.all(pagePromises);

       // Create a new document to add the processed pages to.
       // This avoids modifying the original template directly and might help with some issues.
      const finalDoc = await PDFDocument.create();

      for (const page of pages) {
         const [copiedPage] = await finalDoc.copyPages(page.doc, [page.doc.getPages().indexOf(page)]);
         finalDoc.addPage(copiedPage);
      }

      // Note: We are NOT removing pages from the original f8949 template.
      // We are building finalDoc from the processed copies.

      const filename = `f8949_${year}_filled.pdf`; // Add .pdf extension
      return finalDoc.save().then(data => new File([data.buffer], filename, { type: 'application/pdf' }));
    }

    function download(file) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(file);
      a.download = file.name;
      document.body.appendChild(a); // Append anchor to body to ensure click works in all browsers
      a.click();
      document.body.removeChild(a); // Clean up the anchor
      URL.revokeObjectURL(a.href); // Release the object URL
    }

    async function parseCsv(file, hasHeaders) {
      return new Promise((resolve, reject) => { // Return the promise
        if (!file || !(file instanceof File)) {
           return reject(new Error("Invalid file provided for parsing."));
        }
        Papa.parse(file, {
          header: false,
          skipEmptyLines: 'greedy',
          complete: (results) => {
              console.log(`Parsed ${file.name}:`, results);
              if (results.errors && results.errors.length > 0) {
                  console.error("CSV Parsing errors:", results.errors);
                   // Reject with the first error message
                  return reject(new Error(`CSV Parsing Error (${results.errors[0].code}): ${results.errors[0].message} on row ${results.errors[0].row}`));
              }
              const data = results.data;
              if (hasHeaders && data.length > 0) {
                data.shift(); // Remove header row
              }
              // Ensure all rows have the same number of columns (8), padding with empty strings if necessary
              const expectedColumns = 8;
               const standardizedData = data.map(row => {
                  if (!Array.isArray(row)) return []; // Handle potential non-array rows
                  const newRow = [...row]; // Copy the row
                  while (newRow.length < expectedColumns) {
                      newRow.push(''); // Add empty strings to pad
                  }
                  // Truncate if more columns than expected (optional, depends on desired behavior)
                  // return newRow.slice(0, expectedColumns);
                   return newRow;
               });
              resolve(standardizedData);
          },
          error: (error) => {
              console.error("CSV Parsing failed:", error);
              reject(error);
          }
        });
      });
    }

    document.querySelector('#template-link').addEventListener('click', e => {
      e.preventDefault();
      const csv = '"Description of property","Date acquired","Date sold or disposed of","Proceeds (sales price)","Cost or other basis","Code(s) from instructions","Amount of adjustment","Gain or (loss)"';
      // Example Row (Optional - can be added below the header):
      // \n"100 sh. Example Corp","01/15/2022","12/15/2023","10000.00","5000.00","","","5000.00"
      const encoded = new TextEncoder().encode(csv);
      const file = new File([encoded], 'template.csv', { type: 'text/csv;charset=utf-8' }); // Specify charset
      download(file);
    });

    formElement.addEventListener('submit', async (e) => {
      e.preventDefault(); // Prevent default form submission

      // Prevent multiple submissions
      if (formElement.hasAttribute('data-submitting')) {
        return;
      }
      formElement.setAttribute('data-submitting', '');
      spinner.style.display = 'inline-block'; // Show spinner

      // Use Promise.finally to ensure cleanup happens
      let pdfGenerated = false; // Flag to track success

      try {
        const formData = new FormData(formElement); // Use the correct form element
        const year = formData.get('year');
        const shortFile = formData.get('short');
        const longFile = formData.get('long');
        const hasHeaders = formData.get('headers') === 'on';
        const isStatic = formData.get('format') === 'static';

        // Basic file validation
        if (!shortFile || shortFile.size === 0 || !longFile || longFile.size === 0) {
            throw new Error('Please select both short-term and long-term CSV files.');
        }

        // Parse CSV files
        console.log('Parsing CSV files...');
        const [shortData, longData] = await Promise.all([
          parseCsv(shortFile, hasHeaders),
          parseCsv(longFile, hasHeaders)
        ]);
        console.log('CSV parsing complete.');
        console.log('Short-term data rows:', shortData.length);
        console.log('Long-term data rows:', longData.length);

        if (isStatic) {
          console.log('Generating static PDF...');
          // Generate static PDF - uses its own promise chain internally
          const staticPdfFile = await generateStaticPDF(year, shortData, longData);
           if (staticPdfFile instanceof File) {
               console.log('Static PDF generated successfully:', staticPdfFile.name);
               download(staticPdfFile);
               pdfGenerated = true;
           } else {
               // This case should ideally not happen if generateStaticPDF resolves correctly
               throw new Error('Static PDF generation failed to return a valid file.');
           }

        } else {
          // Generate form-based PDF
          console.log('Generating fillable PDF...');
          const templateUrl = `./forms/f8949--${year}.pdf`; // Use relative path from HTML file
          console.log(`Fetching template: ${templateUrl}`);

          const response = await fetch(templateUrl);
          console.log(`Fetch response status: ${response.status}`);
          if (!response.ok) {
            throw new Error(`Failed to fetch PDF template: ${response.status} ${response.statusText}. Check if the file exists at ${templateUrl}.`);
          }
          const f8949Bytes = await response.arrayBuffer();
          console.log(`Template fetched (${f8949Bytes.byteLength} bytes). Generating filled form...`);

          // generate8949 returns a promise that resolves with the file
          const filledPdfFile = await generate8949(f8949Bytes, year, shortData, longData);
           if (filledPdfFile instanceof File) {
               console.log('Fillable PDF generated successfully:', filledPdfFile.name);
               download(filledPdfFile);
               pdfGenerated = true;
           } else {
               throw new Error('Fillable PDF generation failed to return a valid file.');
           }
        }

      } catch (error) {
        // Catch errors from parsing, fetching, or PDF generation
        console.error('Error during form processing:', error);
        alert(`An error occurred: ${error.message || 'Please check console for details.'}`);
        // pdfGenerated remains false

      } finally {
        // This block always runs, regardless of success or caught error
        console.log('Form processing finished. Cleaning up...');
        spinner.style.display = 'none'; // Hide spinner
        formElement.removeAttribute('data-submitting'); // Re-enable button
        // Optional: Provide feedback based on success
        if (pdfGenerated) {
            console.log("PDF download initiated.");
            // Maybe add a temporary success message on the page
        } else {
             console.log("PDF generation/download did not complete successfully.");
        }
      }
    });

  </script>
</body>

</html>